[{"content":"Abstract This topic isn‚Äôt new. When I first learned about State Tree, it was introduced as something that could be used not just for AI, but for many other systems ‚Äî doors, crates, quests, game logic, and so on.\nFor AI, its use is quite straightforward. But when I thought about applying State Tree to other systems, I honestly couldn‚Äôt see how it would make sense. For example:\nüö™ Door system: You only need a simple boolean or enum to represent the door state. Using a full State Tree feels like overkill. üéØ Quest system: Most quests I‚Äôve seen are relatively simple (or maybe I‚Äôm just a normie) ‚Äî kill 10 frogs, open 10 chests, talk to NPC A to retrieve item B. State Tree‚Äôs functionality seems way too powerful for that. ‚úÖ And I was right - for simple mechanics where you just need something quick, there‚Äôs no need to use State Tree. You will probably spend more time learning the State Tree and dealing with headaches than creating an actual fun game.\n=\u0026gt; But if your system becomes more complicated, you should consider using State Tree before you start reinventing the wheel ‚Äî like I did.\nBenefits Modular and readable: Even if you‚Äôre not the one who built it, you can still understand the logic easily (as shown in the screenshots above). Colorful decorative opitons: State Tree allows you to color the state based on the Category, they even let you set the icon / description to make that more understandable from the outside of the tree-view Fast iteration: You can reorder states, disable them, or split the tree into multiple files so teammates can work on it simultaneously. Feature-rich: Transitions, evaluators, conditions, tasks, and more ‚Äî it‚Äôs far more capable than a basic state machine, so you don‚Äôt have to reinvent the wheel. Built-in debugging tools: You can visualize states, transitions, and condition results in real time, making it much easier to track down logic issues. Examples of State Tree besides AI You can use State Tree to handle a FTUE (First Time User Experience) flow.\nOr you can use it to implement a new game mode.\nI found State Tree extremely useful when implementing systems like tutorials or game modes. It allows you to execute tasks in sequence and handle complex transitions. Additionally, it manages resources in a tree-like structure. Essentially, any child node can use resources defined by its parent, and when a state exits, its associated resources are cleared (though you need to handle that manually).\nThis resource scoping makes it much safer for Game Designers to work with compared to directly editing GameMode Blueprints.\nFor example: in one tutorial, I needed to spawn dummies that must stay alive until the tutorial ends. Every task under that tutorial could access and interact with those dummies directly.\nNotes Along the Way I‚Äôm still learning from the community, but here are a few things to keep in mind before integrating State Tree into your project. I\u0026rsquo;ll try to update this as I have more chance to work with State Tree in the future.\nRecommend using State Tree in UE 5.4 or above.\nAlthough Unreal claims State Tree has been ‚Äúproduction-ready‚Äù since 5.1, the earlier versions were limited with bugs and crashes (Reference). From my experience, 5.4 and above is where it finally becomes reliable enough for real use. Version 5.6 is an even better starting point, as it fixes many long-standing issues and adds key features like delegates. If you‚Äôre on an older version, proceed with caution ‚Äî you‚Äôll likely hit blockers sooner or later. In 5.5 and below, note that when any task in a state completes, the state itself is also considered complete.\nFor async tasks (that keep running until their children finish), either avoid calling FinishTask, or expose a boolean parameter to control it ‚Äî allowing you to reuse that task in different scenarios.\nIn 5.6, you can now decide whether a state finishes when all tasks complete or when any task completes, offering much more flexibility. Use Global Tasks or Evaluators to dynamically initialize or update shared variables and parameters (for example, retrieving the player list).\nYou can then access the output parameters from anywhere in the State Tree.\nNote that if any global task completes, the entire State Tree will also complete ‚Äî effectively stopping it. Use States and Transitions thoughtfully to define execution order and maintain clarity in your flow.\nYour tasks should only perform their work, finish, and let the State Tree handle routing.\nIf you want a task to handle routing itself (for example, a global async task waiting for all enemies in the level to be cleared before transitioning to an end game state), you have two options: Use StateTree Send Event to send an event with a GameplayTag. You‚Äôll need to configure your State Tree to transition correctly based on that event tag. Use StateTree Request Transition. This method is more straightforward, allowing you to transition directly to the Target State without needing to create multiple GameplayTags. However, this function is broken in UE 5.5 and below (it was rewritten and fixed in 5.6). If you still want to use it, check out my fix. ","permalink":"https://teambaconn.github.io/unreal-post/state-tree-beyond-ai/","summary":"State Tree examples for game systems","title":"[Unreal] Using State Tree Beyond AI"},{"content":"\rIntroduction Bacon Combo Graph is an Unreal Engine plugin (UE5.4+) designed to help you build complex, animation-driven combat systems fast and easy. With a custom visual editor, native GAS support, and multiplayer-ready design, it\u0026rsquo;s perfect for devs who want clean workflow and fast iteration ‚Äî especially for melee or combo-heavy games.\nThe plugin got featured on 80 Levels and receive a lot of positive feedbacks (Article) - (Reddit)\nüìã Quick Start üìñ Documentation ü™µ Changelog üó®Ô∏è Discord Server üìº Tutorial ‚ö†Ô∏è Disclaimers Plugin is under active development. More updates coming! Found a bug or have feedback? Just reach out in the Discord server ‚Äî I‚Äôll respond as soon as possible. The plugin only supports Unreal 5.4 and onward. Lower Unreal versions require manual fixes and functional limitation. The plugin provides a demo out of the box but NOT a whole shipped game for you to plug and play seemlessly in your own project. You will have to integrate the plugin with your game systems (tutorial below), but after that, creating new content is fast and intuitive. Animations are not included ‚Äî use your own or grab packs from the Marketplace. The animations for the demo are from \u0026ldquo;RamsterZ Free Anims Volume 1\u0026rdquo; pack. Please read the Features section carefully to see if it matches your need before buying the plugin. Any request outside of the features scope will be put into backlog for future improvements (will not be immediately supported) Features Custom editor tool to design complex combo sequence Multiple graph nodes, fully extendable to suit your game logics Animation driven system integration to communicate seamlessly between Animation / Montage and Gameplay Abilities Hitbox system implemented with multiple pre-made shapes (box, sphere, capsule, ring,\u0026hellip;) Combo window, complex input like one click attack or charge attack (supported by Enhanced Input System) are included and supported by the graph With the features above suitable for making Soul like, beat em up, hack \u0026amp; slash games.\nInstallation There are no special step to install this plugin. Just make sure the plugin is enabled in the Plugins window. Or you can manually install it by following these step:\nCreate a Plugins folder in your project\u0026rsquo;s root folder Put the BaconComboGraph into the Plugins folder Make sure you include and enable it in the .uproject or the Plugins window. ","permalink":"https://teambaconn.github.io/plugin/combo-graph/overview/","summary":"Bacon Combo Graph is an Unreal Engine plugin (UE5.4+) designed to help you build complex, animation-driven combat systems fast and easy","title":"Bacon Combo Graph"},{"content":"1.1.3 (Latest on FAB) Compatibility UE 5.4 ‚Äì 5.6 Bug Fixes feat: Allow users to make custom ComboGraphAsset (inherit from UComboGraphAsset) and be able to create the Combo Graph from their custom base class. 1.1.2 Compatibility UE 5.4 ‚Äì 5.6 Bug Fixes fix: Fix crash when activating context ability which the ASC is on the PlayerState not the Character / Pawn. note: Keep in mind, GetAvatarActor function of the ASC must return the Character / Pawn. If it return something else such as PlayerState, some of the functions in this plugin will be broken. There are 2 ways to fix this, change your avatar actor to the character or change the code in my plugin to adapt with your \u0026ldquo;Avatar Actor\u0026rdquo; version. 1.1.1 Compatibility UE 5.4 ‚Äì 5.5 Bug Fixes feat: Add UActionPass_ActivateGenericAbility to activate normal UGameplayAbility. UActionPass_ActivateAbility will only be able to activate ability derived from UContextAbility class. 1.1 Compatibility UE 5.4 ‚Äì 5.5 Bug Fixes fix: Support multiple damage notifies in a single frame.\nPreviously only one notify could trigger per frame; this update ensures all overlapping notifies are processed correctly. 1.0 Compatibility UE 5.4 ‚Äì 5.5 New Features feat: Initial release of ComboGraph. Visual graph editor for designing combo sequences. Directional branching, animation timing, and input buffering. Runtime component for execution in both C++ and Blueprints. Includes demo map: L_Demo. ","permalink":"https://teambaconn.github.io/plugin/combo-graph/changelog/","summary":"\u003ch2 id=\"113-latest-on-fab\"\u003e1.1.3 (Latest on FAB)\u003c/h2\u003e\n\u003ch4 id=\"compatibility\"\u003eCompatibility\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003eUE \u003ccode\u003e5.4\u003c/code\u003e ‚Äì \u003ccode\u003e5.6\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"bug-fixes\"\u003eBug Fixes\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003efeat\u003c/strong\u003e: Allow users to make custom ComboGraphAsset (inherit from \u003ccode\u003eUComboGraphAsset\u003c/code\u003e) and be able to create the Combo Graph from their custom base class.\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch2 id=\"112\"\u003e1.1.2\u003c/h2\u003e\n\u003ch4 id=\"compatibility-1\"\u003eCompatibility\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003eUE \u003ccode\u003e5.4\u003c/code\u003e ‚Äì \u003ccode\u003e5.6\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"bug-fixes-1\"\u003eBug Fixes\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003efix\u003c/strong\u003e: Fix crash when activating context ability which the ASC is on the PlayerState not the Character / Pawn.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003enote\u003c/strong\u003e: Keep in mind, \u003ccode\u003eGetAvatarActor\u003c/code\u003e function of the ASC must return the Character / Pawn. If it return something else such as \u003cstrong\u003ePlayerState\u003c/strong\u003e, some of the functions in this plugin will be broken.\nThere are 2 ways to fix this, change your avatar actor to the character or change the code in my plugin to adapt with your \u0026ldquo;Avatar Actor\u0026rdquo; version.\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch2 id=\"111\"\u003e1.1.1\u003c/h2\u003e\n\u003ch4 id=\"compatibility-2\"\u003eCompatibility\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003eUE \u003ccode\u003e5.4\u003c/code\u003e ‚Äì \u003ccode\u003e5.5\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"bug-fixes-2\"\u003eBug Fixes\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003efeat\u003c/strong\u003e: Add UActionPass_ActivateGenericAbility to activate normal UGameplayAbility. UActionPass_ActivateAbility will only be able to activate\nability derived from UContextAbility class.\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch2 id=\"11\"\u003e1.1\u003c/h2\u003e\n\u003ch4 id=\"compatibility-3\"\u003eCompatibility\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003eUE \u003ccode\u003e5.4\u003c/code\u003e ‚Äì \u003ccode\u003e5.5\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"bug-fixes-3\"\u003eBug Fixes\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003efix\u003c/strong\u003e: Support multiple damage notifies in a single frame.\u003cbr\u003e\nPreviously only one notify could trigger per frame; this update ensures all overlapping notifies are processed correctly.\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch2 id=\"10\"\u003e1.0\u003c/h2\u003e\n\u003ch4 id=\"compatibility-4\"\u003eCompatibility\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003eUE \u003ccode\u003e5.4\u003c/code\u003e ‚Äì \u003ccode\u003e5.5\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"new-features\"\u003eNew Features\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003efeat\u003c/strong\u003e: Initial release of ComboGraph.\n\u003cul\u003e\n\u003cli\u003eVisual graph editor for designing combo sequences.\u003c/li\u003e\n\u003cli\u003eDirectional branching, animation timing, and input buffering.\u003c/li\u003e\n\u003cli\u003eRuntime component for execution in both C++ and Blueprints.\u003c/li\u003e\n\u003cli\u003eIncludes demo map: \u003ccode\u003eL_Demo\u003c/code\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e","title":"Changelog"},{"content":"‚ö†Ô∏è Usage Modes ‚Äì Read Before Using This plugin supports two modes, and setup/implementation may differ depending on the mode. These differences will be clearly annotated in the documentation as GAS or Generic use cases:\nChoose the mode that best fits your project setup.\rGAS Mode (Recommended):\n‚úÖ Works well with Gameplay Ability System\n‚úÖ Full feature support\n‚úÖ Built-in replication via GAS Generic Mode:\n‚úÖ Full feature support\n‚ùå No replication support ‚Äì manual replication is required if needed Node Types Root Node Root node is the starting point of the graph. When the graph resets, it returns to this node.\nExecution Node Used to perform actions, such as playing animations, consuming mana, or triggering gameplay effects.\nEach Execution Node can contain multiple Action Passes. Passes are executed from top to bottom. If any pass fails, execution stops and follows the Fail output pin. Creating a Custom Action Pass Create a custom Action Pass by inheriting from UComboActionPass.\nExamples:\nC++: UComboActionPass_PlayMontage Blueprint: CAP_Generic_Attack Tip: CAP stands for Combo Action Pass. It\u0026rsquo;s a useful prefix for filtering in the editor.\nCondition Branch Acts like an IF statement. The node will evaluates one or more Condition Passes using logical operators (e.g., AND, OR) and determines which path to take.\nCreating a Custom Condition Pass Create a custom Condition Pass by inheriting from UComboConditionPass.\nExamples:\nC++: UComboConditionPass_EnoughStat Blueprint: CCP_ConditionExample Tip: CCP stands for Combo Condition Pass.\n‚ö†Ô∏è Condition Passes must only call const functions. They should not change game state. If you need to change state or trigger events, use an Execution Node instead.\nInput Node Waits for a specific player input before continuing the combo.\nYou define input types using Gameplay Tags and can integrate with the Enhanced Input System for more advanced input handling.\nHow to Create a New Input Define a GameplayTag that starts with ComboGraph.Input, e.g., ComboGraph.Input.HeavyAttack.\nYou can manage your tags in a DataTable using FGameplayTagTableRow.\nCreate an Input Action if you\u0026rsquo;re using the Enhanced Input System. (If you are not using Enhanced Input System, then you can skip this step)\nIn your PlayerController or Character, bind the input event and trigger the combo graph using the tag you defined.\nFor more advanced control, you can add direction to the tag.\nExample: ComboGraph.Input.HeavyAttack.B can represent a backward heavy attack.\nThis will match input nodes with ComboGraph.Input.HeavyAttack.B or its parent ComboGraph.Input.HeavyAttack. How to use directional input Reset Node Resets the graph and returns execution to the Root Node.\nPortal / Portal Jump Node These nodes allow for function-like behavior within the graph.\nUse them to simplify complex graphs or to jump to specific locations in the graph based on gameplay logic.\nHow to Use Create a Portal Node and assign it a unique Gameplay Tag. Use a Portal Jump Node to jump to that tag. If the specified tag doesn\u0026rsquo;t exist, execution fails and returns to the Root Node. ‚ö†Ô∏è Only one Portal Node per tag is allowed. However, you can have multiple Jump Nodes referencing the same tag.\n","permalink":"https://teambaconn.github.io/plugin/combo-graph/documentation/","summary":"\u003ch1 id=\"-usage-modes--read-before-using\"\u003e‚ö†Ô∏è Usage Modes ‚Äì Read Before Using\u003c/h1\u003e\n\u003cp\u003eThis plugin supports \u003cstrong\u003etwo modes\u003c/strong\u003e, and setup/implementation may differ depending on the mode. These differences will be clearly annotated in the documentation as \u003cstrong\u003eGAS\u003c/strong\u003e or \u003cstrong\u003eGeneric\u003c/strong\u003e use cases:\u003c/p\u003e\n\r\n\r\n\r\n\r\n\r\n\u003cspan style=\"\r\n    background-color: #FFD700; \r\n    padding: 2px 4px; \r\n    margin: 1px; \r\n    border-radius: 2px;\r\n    font-size: 95%;\r\n\"\u003e\r\n  \u003cspan style=\"\r\n    color: black;\r\n    font-weight: ;\r\n  \"\u003e\r\n    Choose the mode that best fits your project setup.\r\n  \u003c/span\u003e\r\n\u003c/span\u003e\r\n\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eGAS Mode\u003c/strong\u003e (Recommended):\u003cbr\u003e\n‚úÖ Works well with Gameplay Ability System\u003cbr\u003e\n‚úÖ Full feature support\u003cbr\u003e\n‚úÖ Built-in replication via GAS\u003c/li\u003e\n\u003c/ul\u003e\n\u003cbr /\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eGeneric Mode\u003c/strong\u003e:\u003cbr\u003e\n‚úÖ Full feature support\u003cbr\u003e\n‚ùå \u003cstrong\u003eNo replication support\u003c/strong\u003e ‚Äì manual replication is required if needed\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"node-types\"\u003eNode Types\u003c/h1\u003e\n\u003chr\u003e\n\u003ch2 id=\"root-node\"\u003eRoot Node\u003c/h2\u003e\n\u003cp\u003eRoot node is the starting point of the graph. When the graph resets, it returns to this node.\u003c/p\u003e","title":"Documentation"},{"content":"\r- You can watch the tutorial video and follow the text version below.\n1. Prepare your ACharacter Make sure your Character blueprint or C++ has these components added:\nAnimationDrivenComponent ‚Äì For listening to animation montage data and signaling it to other systems (e.g., gameplay abilities) ComboManagerComponent ‚Äì For managing the combo graph IMPORTANT!!!\rFor GAS Users\rMake sure your Character has AbilitySystemComponent and is derived from UContextAbilitySystemComponent.\nSee ComboBasicCharacter.h for a default GAS implementation.\nOr you can read the GAS installation guide here: Installation doc\nFor Generic Users\rAdd the GameplayTasks component to your Character\u0026rsquo;s Blueprint to use GameplayTasks.\n2. Create a Combo Graph Create the Combo Graph Asset. This is where combat designers primarily work.\nIt stores the full combo tree with branching and variations. Right-click on the graph to open the node creation panel.\nFocus on:\nInput Branch (green node) Execution Node (red node) More node types are covered in the üßä Combo Graph Nodes section.\n3. Create an Input Branch and connect the Start Combo pin from the Root node to the Input pin of the new branch.\nThis marks the entry point of your combo.\nClick the node and configure it using the Node Data panel.\nSpecify which input (via Gameplay Tags) triggers the next combo step.\nTags must begin with ComboGraph.Input (e.g., ComboGraph.Input.Attack). 5. Create an Execution Node and connect it to the previous Input Branch. Add an Execution Pass (e.g., Play Montage) and assign your chosen animation montage. 7. Repeat steps 4‚Äì6 to chain additional combo steps:\nRoot ‚Üí Input ‚Üí Execute (Combo 1) ‚Üí Input ‚Üí Execute (Combo 2) ‚Üí ‚Ä¶\n3. Prepare Input How to create a new input and hook it to the Combo Graph\n4. Setup Combo Graph on Your Character Open your ComboManagerComponent settings and add a default Combo Graph: Select your Combo Graph asset. Select the appropriate graph instance: IMPORTANT!!!\rFor GAS Users\rUse ComboGraphInstance_ASC\nFor Generic Users\rUse ComboGraphInstance_Generic\nGrant combo graph in runtime Swap between combo graphs There can only be one combo graph activated per Character / Combo Manager. To switch the active combo graph in runtime you can use the node below.\nüí° Tip:\nGetCurrentInstance return the current instance but you can add an offset index +1 or -1 to grab the left or right graph instance in the list. If you need to grab an instance with a specific graph asset use GetComboGraphInstanceByAsset function 5. Prepare Your Montage We use animation-driven design: static data is stored in animations and triggered via Notifies.\nOpen the montage used in your Combo Graph. 2. Add these three Notify States:\nBlock Proceed Graph: Prevents combo continuation until it\u0026rsquo;s done. Input Window: Enables player input capture for the next combo. Damage Notify: Triggers hitboxes. 3. Use plugin-provided Notify States:\nHitbox Detection (works on all modes):\nADNS_Damage_LeftFoot ADNS_Damage_LeftSword ‚Ä¶ IMPORTANT!!!\rFor GAS Users\rANS_GAS_InputWindow ANS_GAS_ComboWindow For Generic Users\rANS_Generic_InputWindow ANS_Generic_ComboWindow 6. Implement Hitbox \u0026amp; Damage The plugin provides built-in collision detection for both GAS and non-GAS setups.\nIMPORTANT!!!\rFor GAS Users\rUse the GA_CombatAbility_Base and override the OnHit function to handle hit events.\nFor Generic Users\rRefer to CBP_BasicComboCharacter ‚Üí BeginPlay for a complete example.\nIt\u0026rsquo;s the same as when using GAS but instead of using AbilityTask, you‚Äôll implement hit logic using GameplayTask from your character or component blueprint.\n","permalink":"https://teambaconn.github.io/plugin/combo-graph/quick-start/","summary":"\u003cdiv style=\"position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;\"\u003e\r\n          \u003ciframe allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen=\"allowfullscreen\" loading=\"eager\" referrerpolicy=\"strict-origin-when-cross-origin\" src=\"https://www.youtube.com/embed/oyybI_qCwcw?autoplay=0\u0026amp;controls=1\u0026amp;end=0\u0026amp;loop=0\u0026amp;mute=0\u0026amp;start=0\" style=\"position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;\" title=\"YouTube video\"\u003e\u003c/iframe\u003e\r\n        \u003c/div\u003e\n\u003cp\u003e\u003cem\u003e- You can watch the tutorial video and follow the text version below.\u003c/em\u003e\u003c/p\u003e\n\u003ch2 id=\"1-prepare-your-acharacter\"\u003e1. Prepare your ACharacter\u003c/h2\u003e\n\u003cp\u003eMake sure your Character blueprint or C++ has these components added:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eAnimationDrivenComponent\u003c/code\u003e ‚Äì For listening to animation montage data and signaling it to other systems (e.g., gameplay abilities)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eComboManagerComponent\u003c/code\u003e ‚Äì For managing the combo graph\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\r\n\r\n\r\n\r\n\r\n\u003cspan style=\"\r\n    background-color: red; \r\n    padding: 2px 4px; \r\n    margin: 1px; \r\n    border-radius: 2px;\r\n    font-size: 95%;\r\n\"\u003e\r\n  \u003cspan style=\"\r\n    color: white;\r\n    font-weight: bold;\r\n  \"\u003e\r\n    IMPORTANT!!!\r\n  \u003c/span\u003e\r\n\u003c/span\u003e\r\n\n\u003cbr\u003e\n\u003cbr\u003e\n\r\n\r\n\r\n\r\n\r\n\u003cspan style=\"\r\n    background-color: #FFD700; \r\n    padding: 2px 4px; \r\n    margin: 1px; \r\n    border-radius: 2px;\r\n    font-size: 95%;\r\n\"\u003e\r\n  \u003cspan style=\"\r\n    color: black;\r\n    font-weight: bold;\r\n  \"\u003e\r\n    For GAS Users\r\n  \u003c/span\u003e\r\n\u003c/span\u003e\r\n\u003c/p\u003e","title":"Quick Start"},{"content":"This post gathers some of the most useful resources I‚Äôve come across ‚Äî from general Unreal knowledge and multiplayer guides to the Gameplay Ability System (GAS) and advanced debugging techniques. Whether you‚Äôre a beginner or deep into production, these links can save you hours of searching.\nüí° Unreal General Knowledge Deep Unreal C++ topics with code demos: YouTube ‚Äî enigma_dev Unreal Notes (information is not fully documented but often golden if you dig deep): ikrima.dev UE4 Guide Unreal Knowledge Base (mostly in Chinese, includes interesting topics about UnLua framework): UE5 Wiki Understanding Unreal Engine cycles and loops: YouTube ‚Äî Unreal Engine Cycles/Loops Smart pointers: Epic - All about Soft and Weak pointers Modules: Epic - Unreal Engine\u0026rsquo;s C++ Modules üåê Multiplayer Knowledge A great starting point for multiplayer basics: Multiplayer Starter Knowledge General multiplayer tips and tricks (must read): Wizardcell Multiplayer Tips üó°Ô∏è Gameplay Ability System (GAS) The ultimate GAS knowledge base: GAS Documentation by tranek Full setup example project: Narxim-GAS-Example üêû Debugging Advanced multi-purpose debugging plugin (works well with GAS): Cog Debugging Plugin Advanced debugging techniques using an IDE: Epic Games Advanced Debugging Tutorial üß∞ Debugging Tip: Paste the following lines into Rider‚Äôs variable watcher (exclude the comments) for quick insights during breakpoints:\n// Check if the breakpoint is on the client or server {,,UnrealEditor-Engine.dll}::GPlayInEditorContextString // Display the current frame count {,,UnrealEditor-Core.dll}::GFrameCounter // View the current game configuration {,,UnrealEditor-Core.dll}::GConfig ","permalink":"https://teambaconn.github.io/unreal-post/external-resources/","summary":"A collection of valuable resources for Unreal Engine developers, covering general knowledge, multiplayer, GAS, and advanced debugging tools","title":"[Unreal] External Knowledge"},{"content":"What is animation driven? Animation driven is a term usually refers to systems or mechanics where some aspects in a system are controlled directly by animations‚Äîrather than calculated through physics or pure code logic.\nAnimations essentially authorize the system to perform certain actions in-game such as moving, dealing damage, spawning hitboxes, performing grab attacks, picking up items\u0026hellip;\nIf the animation gets interrupted, most of those events simply won‚Äôt trigger. I say most because sometimes, for balance reasons, a game might choose to ignore the interruption and still execute the event anyway.\nThe difference between animation-driven and logic-driven systems It all comes down to one question: Who's making the decision?\nLet‚Äôs take a simple AOE skill as an example and compare two different implementations:\nLogic-driven system:\n‚ÄúThe system plays the animation and drives the logic itself.‚Äù\nIn this setup, the skill system plays the animation, then waits for 0.4s before telling the damage system to apply AOE damage.\nAnimation-driven system:\n‚ÄúThe animation feeds data into the system and trigger the logics‚Äù\nHere, the skill system still plays the animation, but instead creating a timer to wait for 0.4s, it waits for the animation to notify the system when to apply damage, and how large / powerful the AOE should be. Usually for static data that doesn\u0026rsquo;t need to change in runtime (dynamic), it can be stored in the animation data for beter and centralized visualization (see the image below).\nWhen should you use an animation-driven system? TL;DR: If you\u0026rsquo;re making a Souls-like game just use it.\nYou should consider using animation-driven systems when:\nYou\u0026rsquo;re aiming for realistic gameplay where animation and logic need to be tightly synced Your animations vary in speed and that variation affects timing of gameplay events You want game designers to balance and tweak things visually, without the longgg config \u0026amp; test loop Honestly, creating new content in an animation-driven system is often much easier. You can see exactly what\u0026rsquo;s happening, and tweaking animations gives you immediate feedback on how the gameplay feels.\nEven better, moving some logic into animation assets lets game designers create and test content quickly, without needing a programmer to step in. That means faster iteration and more time for devs to focus on deeper systems or fixing that one annoying bug that only happens on Friday üòÖ.\nAnimation-Driven System in Unreal Implementation The image above is an example of how I think an animation-driven system should be implemented for Gameplay Ability System in Unreal.\nFor other systems, you can use the same approach, it just in different by names.\nI\u0026rsquo;ve annotated the steps in the image, from start (ActivateAbility) to end (EndAbility). Here\u0026rsquo;s a breakdown:\nThe ability gets activated and plays a montage.\nUse the PlayMontageAndWait ability task from GAS as it already has built-in delegates and handles replication for multiplayer. The ability waits for one of the relevant montage events (OnCompleted, OnInterrupted, OnBlendOut) to end or cancel the ability. While the montage plays, any animation notify it hits will send data to a custom component called AnimationDrivenProxyComponent.\nThat component then broadcasts the OnDataReceiveDelegate delegate. The ability task binds to OnDataReceiveDelegate delegate in the AnimationDrivenProxyComponent to listen for notify data.\nMake sure it only listens to relevant data‚Äîsince multiple montages might be playing at once.\nFor example: if your animation-driven ability plays Montage A, then the task should only react to notify data coming from Montage A. Once the ability task receives the notify data, it drives the logic of the ability accordingly. Notes Animation Notifies and Notify States are STATELESS as they\u0026rsquo;re shared across animation instances, so only use them for static data.\nIf you need to listen to NotifyState tick functions, don‚Äôt flood AnimationDrivenProxyComponent with updates.\nInstead, only send NotifyBegin and NotifyEnd‚Äîlet the ability task handle ticking if needed. It‚Äôs more efficient that way.\nOn dedicated servers (not listen servers), skeletal meshes don\u0026rsquo;t tick, meaning no animation plays on the server-side.\nThus, if you‚Äôre spawning a hitbox on a moving socket (like a sword swing), it might just float there on the server.\nTo fix this, you‚Äôll need to force the mesh to tick pose during montage playback. Add this in your ACharacter constructor or BeginPlay:\n#ifdef WITH_SERVER_CODE GetMesh()-\u0026gt;VisibilityBasedAnimTickOption = EVisibilityBasedAnimTickOption::OnlyTickMontagesAndRefreshBonesWhenPlayingMontages; #else // Default client setting GetMesh()-\u0026gt;VisibilityBasedAnimTickOption = EVisibilityBasedAnimTickOption::OnlyTickPoseWhenRendered; #endif A notify placed at the very beginning of the animation is not guaranteed to fire immediately. If you do something like: Play Animation A ‚Üí Expect Notify to fire ‚Üí Check for that event in the same frame ‚Ä¶it might fail, because the notify may not trigger until the next animation tick. Solution: If the logic must happen right after playing the animation, don‚Äôt rely on the notify. Trigger it manually after playing the animation, or delay your logic by 1 frame. The notify that you put in the end will NOT be guaranteed to hit, since the animation could be interupted or blend out too early. Only Notify State will hit end if your animation finishes early (only if the NotifyBegin has already triggered). ","permalink":"https://teambaconn.github.io/unreal-post/animation-driven/","summary":"A general overview of animation-driven systems in game development, along with practical tips and implementation strategies for building them using GAS.","title":"[Unreal] Animation Driven System"},{"content":"‚ö†Ô∏è Prerequisites These tips apply to Unreal Engine 5 and later. If you\u0026rsquo;re working with an older version, the behavior might be different. Feel free to reach out if any of my information is incorrect or misleading. I only mention tips that I believe are not well-documented online. Replicated Tags 1. AddReplicatedLooseGameplayTag (or remove) does not modify tags on the caller side For example, if you add replicated tags on the server, only the clients will receive them (through MinimalReplicationTags replication), but the tag will NOT be added on the server itself.\nIf you want to add or remove the tag on the server and also replicate it to clients, use:\nUAbilitySystemBlueprintLibrary::AddLooseGameplayTag UAbilitySystemBlueprintLibrary::RemoveLooseGameplayTag 2. Do NOT use AddLooseGameplayTag or RemoveLooseGameplayTag on replicated tags to modify them locally (unless you\u0026rsquo;re the authoritative server) Adding or removing a loose gameplay tag on the client will eventually be overridden by the replicated version from the server.\nExample: You add Tag.Example locally on the client five times. On the server, you call AddReplicatedLooseGameplayTag with Tag.Example once. The client‚Äôs tag count gets overridden when the server replicates MinimalReplicationTags. The server does not care how many times the client added the tag locally; only the replicated state matters. Replication Stage Client State Server State Before Replication 5 1 Expected After Replication 6 1 Actual After Replication 1 (Overridden) 1 Workaround: To make the server respect locally added tags, you can create a new tag: Tag.Example.Replicated.\nUse this tag for replication (AddReplicatedLooseGameplayTag, ability tags, etc.). Use Tag.Example for locally added tags. This separation prevents the server from overriding local tags. Specify Tag Prefixes for Blueprint Users In most projects, there are many tags, but certain systems only need to handle a specific group of them. For example, input tags only need to consider tags beginning with ComboGraph.Input.\nBy enforcing tag prefixes, you:\nReduce the risk of selecting the wrong tag. Keep tags organized and readable. Restricting Tags in Blueprints You can enforce tag prefixes by using arbitrary prefixes in different data structures such as FGameplayTag, TArray, and TMap. However, this restriction only works in Blueprints‚ÄîC++ does not enforce it.\nExample Usage: // Restrict TArray tags using Categories UPROPERTY(EditAnywhere, meta = (Categories = \u0026#34;General.Input\u0026#34;)) TArray\u0026lt;FGameplayTag\u0026gt; InputTags; // Restrict TMap tags using GameplayTagFilter UPROPERTY(EditAnywhere, meta = (GameplayTagFilter = \u0026#34;General.SetByCaller\u0026#34;)) TMap\u0026lt;FGameplayTag, float\u0026gt; SetByCallerMagnitudes; // Restrict function parameters (must not be a reference parameter) UFUNCTION(BlueprintCallable, Meta = (GameplayTagFilter = \u0026#34;General.Input\u0026#34;)) void ExampleFunc(FGameplayTag Input); By using these metadata settings, you can improve organization and enforce structured tag usage in your Blueprint systems.\nSerialize TMap\u0026lt;FGameplayTag, float\u0026gt; or any TMap for replication By default TMap is not supported for sending through network. In my game, I have the need to send the TMap\u0026lt;FGameplayTag, float\u0026gt; Params to the clients so I have to do my own serialization. This is the same way GAS use to replicate tag counts.\nUSTRUCT(Blueprintable) struct FReplicatedMapWrapper { GENERATED_USTRUCT_BODY() virtual bool NetSerialize(FArchive\u0026amp; Ar, class UPackageMap* Map, bool\u0026amp; bOutSuccess) override; public: UPROPERTY(BlueprintReadWrite) TMap\u0026lt;FGameplayTag, float\u0026gt; Params; }; template\u0026lt;\u0026gt; struct TStructOpsTypeTraits\u0026lt;FReplicatedMapWrapper\u0026gt; : public TStructOpsTypeTraitsBase2\u0026lt;FReplicatedMapWrapper\u0026gt; { enum { WithNetSerializer = true, }; }; bool FReplicatedMapWrapper::NetSerialize(FArchive\u0026amp; Ar, class UPackageMap* Map, bool\u0026amp; bOutSuccess) { constexpr int32 CountBits = MAX_ELEMENT_COUNT; constexpr int32 MaxCount = ((1 \u0026lt;\u0026lt; CountBits) - 1); if (Ar.IsSaving()) { int32 Count = Params.Num(); if (Count \u0026gt; MaxCount) { UE_LOG(LogTemp, Error, TEXT(\u0026#34;FReplicatedMapWrapper::NetSerialize: Too many params (%d) for replication. Clamping to %d.\u0026#34;), Count, MaxCount); Count = MaxCount; } Ar.SerializeBits(\u0026amp;Count, CountBits); for (auto\u0026amp; It : Params) { FGameplayTag Tag = It.Key; float Value = It.Value; Tag.NetSerialize(Ar, Map, bOutSuccess); Ar \u0026lt;\u0026lt; Value; if (--Count \u0026lt;= 0) { break; } } } else { int32 Count = 0; Ar.SerializeBits(\u0026amp;Count, CountBits); Params.Empty(); while (Count-- \u0026gt; 0) { FGameplayTag Tag; float Value = 0.f; Tag.NetSerialize(Ar, Map, bOutSuccess); Ar \u0026lt;\u0026lt; Value; Params.Add(Tag, Value); } } return true; } I hope these insights help you avoid common pitfalls and improve your workflow! If you have any questions or additional tips, feel free to reach out. üöÄ\n","permalink":"https://teambaconn.github.io/unreal-post/gameplay-tag/","summary":"Gotcha tips you might not know when using Gameplay Tags with GAS","title":"[Unreal] Using Gameplay Tags with GAS"},{"content":"About Me My name is Nguyen Lam Tuong (Bacon) I am based in Ho Chi Minh City, Vietnam I have a bachelor\u0026rsquo;s degree in Computer Science from HCM University of Science Check out my üü¶ LinkedIn for the latest updates on my professional profile. Technical Skills Game AI, Gameplay Programming, Tool / Editor Programming Multiplayer Programming Unreal Engine, Unity C++, C#, Lua, Java, Javascript 3D Math, Linear Algebra Web \u0026amp; App Fullstack Development Published Games Sipher Odyssey - Cross Platform\rFramework: Unreal Engine\nResponsibility: Game Engineer\nWebsite: Sipher Odyssey\nDemon Hunter - Mobile\rFramework: BlockmanGO Engine\nResponsibility: Product Owner, Full-stack Developer\nPersonal / Gamejam Projects Most of my games are available on Itch.io\nYou can explore more games from my old portfolio\nProject Brawl - UE5 / PC - Console\rFramework: Unreal Engine\nResponsibility: Solo Developer\nCombat system - UE5 / PC\rFramework: Unreal Engine\nResponsibility: Solo Developer\nMagic Typer - Web / Mobile\rFramework: Unity\nResponsibility: Solo Developer\nFarm Fortune - Web\rFramework: Unity\nResponsibility: Solo Developer\nHellevator - Web / Mobile\rFramework: Unity\nResponsibility: Solo Developer\nChess Factorio - Web\rFramework: Unity\nResponsibility: Solo Developer\nNon-game projects Stylix - Mobile App\rStylix is a mobile app that allows users to virtually try on any clothes before purchase. We accurately analyze the body of users, allowing them to try on any clothes at any time and anywhere. By using state-of-the-art models, our technology can map 2D images of clothes onto the user\u0026rsquo;s body despite their unique shape in no time and at low cost.\nChannel: Youtube Project detail: Milanote FindMe - Web App\rFindMe provides a service that allows filtering of running athletes\u0026rsquo; images based on the athlete\u0026rsquo;s bib number (BIB) and face recognition. Runners can access the product\u0026rsquo;s website after the event finishes, upload their face image, or enter their BIB number to retrieve all of the photos containing their faces or bib in the race.\nProject detail: Milanote ","permalink":"https://teambaconn.github.io/posts/portfolio/","summary":"I am a game developer specializing in systems and gameplay programming in Unreal and Unity, focused on writing efficient, clean code and tackling new challenges in game development.","title":"Tuong Nguyen - Game Developer Portfolio"}]