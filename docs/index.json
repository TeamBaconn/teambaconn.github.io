[{"content":"Abstract It‚Äôs been a while since my last blog post! Recently, I‚Äôve been fully focused on developing my game Project Brawl - a beat ‚Äôem up with local co-op and multiplayer support. And as the title suggests, I ran into quite a few headaches while developing the local co-op features.\nAlthough Unreal technically supports splitscreen out of the box, there‚Äôs almost no proper documentation from Epic explaining how to actually use it in a real project. Every tutorial out there just says something like:\n‚ÄúGo to Project Settings, enable Use Splitscreen, and call CreateLocalPlayer().‚Äù\nSo I thought, \u0026ldquo;Local multiplayer? Easy! Let‚Äôs do it!\u0026rdquo; ‚Äî and then spent weeks struggling to make Unreal‚Äôs already supported feature work as expected. Hopefully, by sharing what I‚Äôve learned here (mostly random stuff), I may save you a lot of that time and frustration and help you get your game local-coop ready much faster üòÑ\n1. ‚öôÔ∏è Guides 1.1 üß± Definitions Before diving in, let\u0026rsquo;s clarify the key terminology you\u0026rsquo;ll encounter:\nFInputDeviceId\rAn ID that identifies a specific input device (keyboard, gamepad, etc.) FPlatformUserId\rAn ID that identifies a LocalPlayer ControllerId\rAn old int32 ID used to identify a LocalPlayer Epic is replacing this with FPlatformUserId in future versions Important: Do not confuse this with PlayerController Local Player\rStores information about a \u0026ldquo;local\u0026rdquo; player on your game\u0026rsquo;s running machine Contains all the InputDeviceIds connected to that player and a FPlatformUserId to identify itself Note: This is not the same as PlayerController A LocalPlayer does not guarantee to have a PlayerController and vice versa (depends on the context) Primary Player\rThe first local player created in the game Different on each client in a multiplayer game Relationship hierarchy:\nLocalPlayer ‚Üí PlayerController ‚Üí Pawn 1.2 üóø Create / Remove Local Player All of the local players are stored in the GameInstance. To create and remove a local player it\u0026rsquo;s quite simple as calling function.\nULocalPlayer* CreateLocalPlayer(int32 ControllerId, FString\u0026amp; OutError, bool bSpawnPlayerController); ULocalPlayer* CreateLocalPlayer(FPlatformUserId UserId, FString\u0026amp; OutError, bool bSpawnPlayerController); // Becareful when using this, as you can accidentally remove the primary local player bool RemoveLocalPlayer(ULocalPlayer * ExistingPlayer); Notes: \u0026nbsp;\rMake sure you enable Use Splitscreen in Project Settings \u0026gt; Maps \u0026amp; Modes \u0026gt; Local Multiplayer, if you wish to have the screen to be split for each local player. If all of the local players share the same screen, then you don\u0026rsquo;t need to enable this. If you have no clue how to get the ControllerId or UserId and just want to spawn a new player, just use ControllerId -1. It should automatically create a new LocalPlayer for you. You should always spawn the player controller (by setting bSpawnPlayerController = true). There are no reason you want to spawn the LocalPlayer without PlayerController since it will automatically spawn a PlayerController for you after switching level. The only reason I can see you doing this is: It\u0026rsquo;s middle of the game, you still want to create a LocalPlayer but not actually doing anything because the game is in progress. And it will automatically spawn the PlayerController after the game ends and switch level. But why letting that, instead just wait until the game finishes? It will create more unexpected behaviors (believe me, I go through the hard way) 1.3 ü™ü Widgets in Local Splitscreen Working with widgets in local splitscreen can be tricky if you\u0026rsquo;re only familiar with single-player games. The key concept to understand is: Each widget is owned by a LOCAL PLAYER and only that player can interact with it\r\u0026nbsp;\r1.3.1 Adding Widget to Global \u0026amp; Local viewport Unreal provides 2 functions to add widgets to the screen:\nUUserWidget::AddToViewport(int32 ZOrder)\nAdds the widget to the global viewport (overlaps all splitscreens when the screen is split) Use this for global widgets like: Pause menus Main menus Global announcements UUserWidget::AddToPlayerScreen(int32 ZOrder)\nAdds the widget to a specific local player\u0026rsquo;s viewport Which player\u0026rsquo;s screen receives the widget depends on the OwningPlayer (PlayerController) you pass when creating the widget Use this for player-specific widgets like: Player HUD Player\u0026rsquo;s local pause menu / settings (like in Lyra) ‚ö†Ô∏è Important: Always assign the OwningPlayer when creating widgets. If left blank, Unreal automatically assigns it to the first Local Player (primary player), or to itself if called from within a PlayerController (see UUserWidget::CreateWidgetInstance for details). While this works for single-player games, local co-op games need deterministic ownership to function correctly.\n1.3.2 üêû WidgetComponent \u0026ldquo;bug\u0026rdquo; When creating character health bars, you\u0026rsquo;ll likely use WidgetComponent to display widgets in either World Space or Screen Space. While both look similar, they behave very differently in local co-op:\nWorld Space:\nRenders the widget on a mesh Visible to any players seeing that mesh Screen Space:\nWidget behaves as if in world space, but is added to A OWNING PLAYER\u0026rsquo;S SCREEN Only visible to the owning player Problem: \u0026nbsp;\rSplit Screen UI widget Component Showing only in Player 0 screen.\nTL;DR: In a 4-player co-op game with Screen Space widgets, only the owning player will see other\u0026rsquo;s health bar and the other 3 players won\u0026rsquo;t see anything at all.\nEven worse: Unreal\u0026rsquo;s implementation is non-deterministic and changes between engine versions:\nUnreal 5.4 and below: The FIRST local player becomes the owner, meaning only the FIRST player sees the widget Unreal 5.5 and above: If the WidgetComponent is attached to a Pawn with a PlayerController, that player becomes the owner, meaning players can only see health bars on themselves, but cannot see others\u0026rsquo; health bars in their viewports. Solution: \u0026nbsp;\rThere are solutions on the internet that suggest that you should manually create each WidgetComponent for each local player and assign ownership accordingly. However, this approach is tedious, error-prone, and can break with engine updates. So instead, here\u0026rsquo;s my take:\nCreate an Actor Component that manages WidgetComponents to ensure all players see all Screen Space widgets, remaining stable across engine versions:\nOn Initialization:\nFind all WidgetComponents (Screen Space only) on the actor Store them in an \u0026ldquo;Original List\u0026rdquo; Disable each original by calling SetWidget(nullptr) For each LocalPlayer currently in the game, run the \u0026ldquo;LocalPlayer Added\u0026rdquo; logic below Listen for LocalPlayer added/removed events (from GameInstance) and run the respective logic When a LocalPlayer is Added:\nFor each WidgetComponent in the Original List: Create a new WidgetComponent instance Copy all settings from the original Call UWidgetComponent::SetOwnerPlayer() with the newly added LocalPlayer Store this cloned widget component for later cleanup When a LocalPlayer is Removed:\nFor each cloned widget component: Check if its OwnerPlayer matches the removed player If yes, destroy/remove that cloned widget Notes:\nEach widget component will now have N copies (where N = number of local players) It\u0026rsquo;s recommended that the widget components should hook into game events to update all copies simultaneously 1.4 Main menu in splitscreen games 1.4.1 Displaying the Menu This is different than ingame UIs since ingame UIs are displayed separately for each local players. For main menu UI, most games use one single screen to display the menu.\nProblem: \u0026nbsp;\rIf splitscreen is still active, the menu appears across multiple viewports, causing the screen to be split even though you only want one unified menu display. Solution: \u0026nbsp;\rUse UGameplayStatics::SetForceDisableSplitscreen(GetWorld(), bDisable);. This forces the game to use one fullscreen viewport, allowing the menu to display correctly.\n1.4.2 Decide who can control and interact with the Menu Only the primary player can control the Menu Most games do this, and it\u0026rsquo;s the default behavior in Unreal. Every local players can control the Menu with the same pointer This easily becomes chaotic. I wouldn\u0026rsquo;t recommend this but if you still want to do this, use IPlatformInputDeviceMapper::Internal_ChangeInputDeviceUserMapping to map every input device of other local player to the primary local player. By doing that, every devices now have control of the menu. But make sure to returns it back once you\u0026rsquo;re in-game. Each local player has their own pointer\nThis is for educational purpose, please Nintendo, don\u0026rsquo;t sue my ass. You will see this mostly in character selection menu in fighting games where you have P1 and P2 pointer floating around to indicate that player\u0026rsquo;s champion selection. This is hard \u0026amp; kinna tedious to implement in my opinion. You will need: One shared widget containing all the actual menu buttons. A separate ‚Äúpointer widget‚Äù for each player, showing only their cursor and selection state. Pointer widgets mirror button positions/behavior from the shared widget (using CommonUI) and sync any shared actions (e.g., locking characters). 1.5 üóø Discover new players You already know how to manually add or remove local players. But how do you let players themselves decide how many should join a session?\nThere are two main approaches.\n1. Let the Primary Player Register/Unregister Others This is the most simple way to implement.\nYou will have a button or a slider that allow the primary player to add and remove local players. As you create new local players, it will automatically paired with any unpaired input device for you.\n‚ö†Ô∏è But the binding is kinna random. If you have 4 gamepads connected and you only want 2 players in the session. Your players will have to figured out which in those 4 gamepads is currently controlling that 2 players.\n2. Let Input Devices Register Themselves This is what most party games do. A \u0026ldquo;Join Game\u0026rdquo; screen shows all available player slots, and anyone can join simply by pressing a button on their controller. The game detects which device sent the input and registers a new player using that device. This way, each player instantly knows which gamepad they‚Äôre using and the host doesn‚Äôt need to manage it manually.\nProblem: \u0026nbsp;\rOnly the primary player has a PlayerController, which can listen for input and interact with the UI. So how do we detect input from unpaired devices that don‚Äôt have a controller yet?\nSolution: \u0026nbsp;\rUnreal provides a delegate that fires whenever any connected device presses or releases a key. Lyra‚Äôs source code includes an example of this system here‚Äôs the basic idea:\n/** Delegate for overriding key input before it is routed to player controllers, returning true means it was handled by delegate */ DECLARE_DELEGATE_RetVal_OneParam(bool, FOverrideInputKeyHandler, FInputKeyEventArgs\u0026amp; /*EventArgs*/); You can get this delegate from a GameViewportClient::OnOverrideInputKey()\n// Enable / disable whenever the \u0026#34;Join Game\u0026#34; screen visible / invisible void ThisClass::EnableListenForInput(bool bEnable) { bListenForLocalPlayerInput = bEnable; if (!bListenForLocalPlayerInput) { // Stop listening: restore the previous handler ViewportClient-\u0026gt;OnOverrideInputKey() = CachedInputKeyHandler; CachedInputKeyHandler.Unbind(); } else { // Start listening: store the current handler so we can call it later CachedInputKeyHandler = ViewportClient-\u0026gt;OnOverrideInputKey(); // Bind our custom function to intercept all key inputs ViewportClient-\u0026gt;OnOverrideInputKey().BindUObject(this, \u0026amp;ThisClass::OnAnyInputKeyEvent); } } In the function\nbool ThisClass::OnAnyInputKeyEvent(FInputKeyEventArgs\u0026amp; InputKeyEventArgs) { // Check if it\u0026#39;s correct key, event, // Check if the local player exists yet by getting the Local Player using ControllerId // If the player not exists, then register // If the player exists, then unregister. BUT BEWARE OF NOT TO REMOVE THE PRIMARY PLAYER // If none of the condition matches above, you can return the input back to the flow so the player controller can capture it // By calling the CachedNative that we stored ealier CachedInputKeyHandler.Execute(InputKeyEventArgs); } 1.6 Press any button screen This is a very common screen in any game. It seem useless but under the hood, it is registering the input device that press the key to control the primary local player. So that player can use that device to control the main menu. Imagining you have 4 gamepads connected to your game, without this screen, the player has to guess what gamepad is controlling the menu.\nSolution: \u0026nbsp;\rWe already have the knowledge about OnOverrideInputKey delegate from the previous section to listen for any device\u0026rsquo;s input without a specific player controller. So implementing this screen is quite simple:\nDisplay the ‚ÄúPress Any Button‚Äù widget. Bind to the OnOverrideInputKey delegate to start listening for input. When any device presses a button, use IPlatformInputDeviceMapper::Internal_ChangeInputDeviceUserMapping to assign that device to the primary player. Note that this function only reassigns a device from one local player to another as it doesn‚Äôt automatically swap them. So you must call it twice (once for each player) to complete the swap; otherwise, one player will have two devices assigned while the other has none. Unbind from OnOverrideInputKey to stop listening. Remove the ‚ÄúPress Any Button‚Äù widget. 1.7 Local Splitscreen and Multiplayer You can have multiple local players on one machine and play with other online players.\nIt sounds daunting but Unreal actually supports both local splitscreen and online multiplayer at the same time quite well.\nUnreal supports sending split join (see ULocalPlayer::SendSplitJoin) for other Local Players when:\nClient Travel to a multiplayer session UGameInstance::CreateLocalPlayer is called on a multiplayer session 2. Notes 2.1 Your graphic will automatically degrade for splitscreen rendering This is understandable since you only have 1 hardware but now you\u0026rsquo;re simulating more than 1 player. The budget will be split down maximum 4 times. So Unreal have some mechanism to degrade the rendering quality by disabling some features.\nProblem: \u0026nbsp;\rThe most important note here is Lumen will be disabled if you have MORE THAN 2 local players in your game. It is clear that Lumen can be quite heavy even for one player. Even if you are building your game for high spec machine, Unreal haven\u0026rsquo;t provide any settings to turn this on.\nSolution: \u0026nbsp;\rThis can only fixed if you use custom build engine LumenDefinitions.h has the field #define LUMEN_MAX_VIEWS 2 which limits the lumen capacity. But increasing that number will cause the engine failed to compile because some of the lumen code is fixed to 2 and not use the constant macro. However, I fixed it you can cherry pick my Git Commit which has been commit to ue5-main.\n2.2 Keyboard and First Gamepad will have the same FInputDeviceId Problem: \u0026nbsp;\rThis causes problems when swapping devices. Unreal treats both the keyboard and the first gamepad as the same device, so swapping one also swaps the other. If you want to swap Gamepad ID 1 with Gamepad ID 0 of Player 1, Unreal swaps ID 1 and ID 0. Because the keyboard also uses ID 0, it gets swapped too.\nExample:\nPlayer 1: - Gamepad ‚Äî ID 0 - Keyboard ‚Äî ID 0 Unassigned: - Gamepad ‚Äî ID 1 Result:\nPlayer 1: - Gamepad ‚Äî ID 1 Unassigned: - Gamepad ‚Äî ID 0 - Keyboard ‚Äî ID 0 Important: \u0026nbsp;\rThis can make your player 1 (primary player) lose keyboard/mouse control. Not a critical bug, but important to know so it doesn\u0026rsquo;t waste hours of debugging.\n","permalink":"https://teambaconn.github.io/unreal-post/local-coop/","summary":"A deep dive into the hidden challenges of building splitscreen multiplayer in Unreal Engine","title":"[Unreal] Splitscreen Multiplayer Guide"},{"content":"Abstract This post will help you better understand how input flows through the UI system in Unreal Engine, especially when working with CommonUI. This is extremely useful when debugging weird CommonUI input issues.\nüìñ Epic provides a more detailed (and accurate) guide here, but honestly, it‚Äôs pretty hard to digest: CommonUI Input Technical Guide\nCommon Problems CommonUI uses an AnalogCursor, which replicates the gamepad‚Äôs Accept button (usually the A button) as a Left Mouse Click and move the cursor to the position of the widget you want to focus on. This leads to two common constrast issues:\nSometimes you need to listen to the actual Accept button, not the simulated left clicks. Sometimes you need to simulate left clicks, but they get consumed by widget bindings that are already listening for the Accept button. Flow Overview When an input event occurs, it travels through a whole chain of systems. Each step has the ability to consume the input. If something consumes your input before it reaches the place you expect, your logic won‚Äôt run.\nTo debug this, place breakpoints from top to bottom in the functions below to find out which layer is stealing your input.\nBelow is a VERY SIMPLIFIED flow chart of how Unreal routes input. I‚Äôve removed everything unnecessary and kept only what matters for debugging CommonUI issues.\n‚ö†Ô∏è Don‚Äôt freak out when you see the chart as I will break down some functions afterwards. üîß Functions breakdown FSlateApplication::InputPreProcessorsHelper::PreProcessInput Runs before Slate/UI receives the event.\nOne of these preprocessors is FCommonAnalogCursor, which:\nChecks if it\u0026rsquo;s a Virtual Accept Key It gives a chance for any widget want to consume the Accept Key through UCommonUIActionRouterBase::ProcessInput If the widget consumes the flow will end here If the widget does not want\u0026rsquo;s it, it will ask it self through ShouldVirtualAcceptSimulateMouseButton to see if it should simulate Left Mouse Button If it simulate, then the input is consumed, if not, we move on to the next step. UCommonUIActionRouterBase::ProcessInput Pushes the input into the widget hierarchy.\nIf a widget has an ActionBinding (like A to Accept, B to Cancel, etc.) and consumes the event:\nThe flow stops here. The input never reaches deeper layers. OnOverrideInputKey() This is a delegate (FOverrideInputKeyHandler) in UCommonGameViewportClient with a bool return that decides whether the input is consumed.\nUsually used for things like:\n\u0026ldquo;Press Any Button to Start\u0026rdquo; screen Local player\u0026rsquo;s device discovery Global-level key capture ‚ö†Ô∏è If CommonUI consumes the event earlier, this delegate never sees it.\nCommon Fixes Disable simulating Virtual Accept key In this senario, you don\u0026rsquo;t want the gamepad to be able to left click on anything so it can be captured by other event. For example: Binding to OnOverrideInputKey() in UCommonGameViewportClient to listen to any input pressed by any input device. This is pretty late step in the chart above and it will get consumed prematurely by the FCommonAnalogCursor when you want to listen for the Accept key.\nSolution You can temporarily disable the FCommonAnalogCursor\u0026rsquo;s left click simulator when listening for Accept key from the OverrideInputKey delegate.\nThe code below shows you how to create your own CommonUIActionRouterBase (LocalPlayerSubsystem) and CommonAnalogCursor so you can enable / disable simulating left mouse button. Just get the local player you want to enable / disable, get the subsystem and use the function SetShouldVirtualAcceptSimulateMouseButton(bool).\n// ¬© 2025 Team Bacon. All Rights Reserved. #pragma once #include \u0026#34;CoreMinimal.h\u0026#34; #include \u0026#34;Input/CommonAnalogCursor.h\u0026#34; #include \u0026#34;Input/CommonUIActionRouterBase.h\u0026#34; #include \u0026#34;ProjectCommonUIActionRouterBase.generated.h\u0026#34; class FProjectCommonAnalogCursor : public FCommonAnalogCursor { public: FProjectCommonAnalogCursor(const UCommonUIActionRouterBase\u0026amp; InActionRouter); protected: virtual bool ShouldVirtualAcceptSimulateMouseButton( const FKeyEvent\u0026amp; InKeyEvent, EInputEvent InputEvent ) const override; }; /** * Project-wide CommonUI Action Router that allows toggling * virtual Accept ‚Üí Left Mouse Button simulation. */ UCLASS() class YOURPROJECT_API UProjectCommonUIActionRouterBase : public UCommonUIActionRouterBase { GENERATED_BODY() public: bool GetShouldVirtualAcceptSimulateMouseButton() const { return bShouldVirtualAcceptSimulateMouseButton; } void SetShouldVirtualAcceptSimulateMouseButton(bool bInShouldSimulate) { bShouldVirtualAcceptSimulateMouseButton = bInShouldSimulate; } protected: virtual TSharedRef\u0026lt;FCommonAnalogCursor\u0026gt; MakeAnalogCursor() const override; protected: bool bShouldVirtualAcceptSimulateMouseButton = true; }; // ¬© 2025 Team Bacon. All Rights Reserved. #include \u0026#34;Subsystem/ProjectCommonUIActionRouterBase.h\u0026#34; FProjectCommonAnalogCursor::FProjectCommonAnalogCursor( const UCommonUIActionRouterBase\u0026amp; InActionRouter ) : FCommonAnalogCursor(InActionRouter) { } bool FProjectCommonAnalogCursor::ShouldVirtualAcceptSimulateMouseButton( const FKeyEvent\u0026amp; InKeyEvent, EInputEvent InputEvent ) const { const UProjectCommonUIActionRouterBase* Router = Cast\u0026lt;UProjectCommonUIActionRouterBase\u0026gt;(\u0026amp;ActionRouter); if (Router \u0026amp;\u0026amp; !Router-\u0026gt;GetShouldVirtualAcceptSimulateMouseButton()) { return false; } return FCommonAnalogCursor::ShouldVirtualAcceptSimulateMouseButton(InKeyEvent, InputEvent); } TSharedRef\u0026lt;FCommonAnalogCursor\u0026gt; UProjectCommonUIActionRouterBase::MakeAnalogCursor() const { return FCommonAnalogCursor::CreateAnalogCursor\u0026lt;FProjectCommonAnalogCursor\u0026gt;(*this); } ","permalink":"https://teambaconn.github.io/unreal-post/common-ui-input-routing/","summary":"An overview into CommonUI input flow","title":"[Unreal] How CommonUI route your input"},{"content":"Abstract This topic isn‚Äôt new. When I first learned about State Tree, it was introduced as something that could be used not just for AI, but for many other systems ‚Äî doors, crates, quests, game logic, and so on.\nFor AI, its use is quite straightforward. But when I thought about applying State Tree to other systems, I honestly couldn‚Äôt see how it would make sense. For example:\nüö™ Door system: You only need a simple boolean or enum to represent the door state. Using a full State Tree feels like overkill. üéØ Quest system: Most quests I‚Äôve seen are relatively simple (or maybe I‚Äôm just a normie) ‚Äî kill 10 frogs, open 10 chests, talk to NPC A to retrieve item B. State Tree‚Äôs functionality seems way too powerful for that. ‚úÖ And I was right - for simple mechanics where you just need something quick, there‚Äôs no need to use State Tree. You will probably spend more time learning the State Tree and dealing with headaches than creating an actual fun game.\n=\u0026gt; But if your system becomes more complicated, you should consider using State Tree before you start reinventing the wheel ‚Äî like I did.\nBenefits Modular and readable: Even if you‚Äôre not the one who built it, you can still understand the logic easily (as shown in the screenshots above). Colorful decorative opitons: State Tree allows you to color the state based on the Category, they even let you set the icon / description to make that more understandable from the outside of the tree-view Fast iteration: You can reorder states, disable them, or split the tree into multiple files so teammates can work on it simultaneously. Feature-rich: Transitions, evaluators, conditions, tasks, and more ‚Äî it‚Äôs far more capable than a basic state machine, so you don‚Äôt have to reinvent the wheel. Built-in debugging tools: You can visualize states, transitions, and condition results in real time, making it much easier to track down logic issues. Examples of State Tree besides AI You can use State Tree to handle a FTUE (First Time User Experience) flow.\nOr you can use it to implement a new game mode.\nI found State Tree extremely useful when implementing systems like tutorials or game modes. It allows you to execute tasks in sequence and handle complex transitions. Additionally, it manages resources in a tree-like structure. Essentially, any child node can use resources defined by its parent, and when a state exits, its associated resources are cleared (though you need to handle that manually).\nThis resource scoping makes it much safer for Game Designers to work with compared to directly editing GameMode Blueprints.\nFor example: in one tutorial, I needed to spawn dummies that must stay alive until the tutorial ends. Every task under that tutorial could access and interact with those dummies directly.\nNotes Along the Way I‚Äôm still learning from the community, but here are a few things to keep in mind before integrating State Tree into your project. I\u0026rsquo;ll try to update this as I have more chance to work with State Tree in the future.\nRecommend using State Tree in UE 5.4 or above.\nAlthough Unreal claims State Tree has been ‚Äúproduction-ready‚Äù since 5.1, the earlier versions were limited with bugs and crashes (Reference). From my experience, 5.4 and above is where it finally becomes reliable enough for real use. Version 5.6 is an even better starting point, as it fixes many long-standing issues and adds key features like delegates. If you‚Äôre on an older version, proceed with caution ‚Äî you‚Äôll likely hit blockers sooner or later. In 5.5 and below, note that when any task in a state completes, the state itself is also considered complete.\nFor async tasks (that keep running until their children finish), either avoid calling FinishTask, or expose a boolean parameter to control it ‚Äî allowing you to reuse that task in different scenarios.\nIn 5.6, you can now decide whether a state finishes when all tasks complete or when any task completes, offering much more flexibility. Use Global Tasks or Evaluators to dynamically initialize or update shared variables and parameters (for example, retrieving the player list).\nYou can then access the output parameters from anywhere in the State Tree.\nNote that if any global task completes, the entire State Tree will also complete ‚Äî effectively stopping it. Use States and Transitions thoughtfully to define execution order and maintain clarity in your flow.\nYour tasks should only perform their work, finish, and let the State Tree handle routing.\nIf you want a task to handle routing itself (for example, a global async task waiting for all enemies in the level to be cleared before transitioning to an end game state), you have two options: Use StateTree Send Event to send an event with a GameplayTag. You‚Äôll need to configure your State Tree to transition correctly based on that event tag. Use StateTree Request Transition. This method is more straightforward, allowing you to transition directly to the Target State without needing to create multiple GameplayTags. However, this function is broken in UE 5.5 and below (it was rewritten and fixed in 5.6). If you still want to use it, check out my fix. ","permalink":"https://teambaconn.github.io/unreal-post/state-tree-beyond-ai/","summary":"State Tree examples for game systems","title":"[Unreal] Using State Tree Beyond AI"},{"content":"\rIntroduction Bacon Combo Graph is an Unreal Engine plugin (UE5.4+) designed to help you build complex, animation-driven combat systems fast and easy. With a custom visual editor, native GAS support, and multiplayer-ready design, it\u0026rsquo;s perfect for devs who want clean workflow and fast iteration ‚Äî especially for melee or combo-heavy games.\nThe plugin got featured on 80 Levels and receive a lot of positive feedbacks (Article) - (Reddit)\nüìã Quick Start üìñ Documentation ü™µ Changelog üó®Ô∏è Discord Server üìº Tutorial ‚ö†Ô∏è Disclaimers Plugin is under active development. More updates coming! Found a bug or have feedback? Just reach out in the Discord server ‚Äî I‚Äôll respond as soon as possible. The plugin only supports Unreal 5.4 and onward. Lower Unreal versions require manual fixes and functional limitation. The plugin provides a demo out of the box but NOT a whole shipped game for you to plug and play seemlessly in your own project. You will have to integrate the plugin with your game systems (tutorial below), but after that, creating new content is fast and intuitive. Animations are not included ‚Äî use your own or grab packs from the Marketplace. The animations for the demo are from \u0026ldquo;RamsterZ Free Anims Volume 1\u0026rdquo; pack. Please read the Features section carefully to see if it matches your need before buying the plugin. Any request outside of the features scope will be put into backlog for future improvements (will not be immediately supported) Features Custom editor tool to design complex combo sequence Multiple graph nodes, fully extendable to suit your game logics Animation driven system integration to communicate seamlessly between Animation / Montage and Gameplay Abilities Hitbox system implemented with multiple pre-made shapes (box, sphere, capsule, ring,\u0026hellip;) Combo window, complex input like one click attack or charge attack (supported by Enhanced Input System) are included and supported by the graph With the features above suitable for making Soul like, beat em up, hack \u0026amp; slash games.\nInstallation There are no special step to install this plugin. Just make sure the plugin is enabled in the Plugins window. Or you can manually install it by following these step:\nCreate a Plugins folder in your project\u0026rsquo;s root folder Put the BaconComboGraph into the Plugins folder Make sure you include and enable it in the .uproject or the Plugins window. ","permalink":"https://teambaconn.github.io/plugin/combo-graph/overview/","summary":"Bacon Combo Graph is an Unreal Engine plugin (UE5.4+) designed to help you build complex, animation-driven combat systems fast and easy","title":"Bacon Combo Graph"},{"content":"1.1.3 (Latest on FAB) Compatibility UE 5.4 ‚Äì 5.6 Bug Fixes feat: Allow users to make custom ComboGraphAsset (inherit from UComboGraphAsset) and be able to create the Combo Graph from their custom base class. 1.1.2 Compatibility UE 5.4 ‚Äì 5.6 Bug Fixes fix: Fix crash when activating context ability which the ASC is on the PlayerState not the Character / Pawn. note: Keep in mind, GetAvatarActor function of the ASC must return the Character / Pawn. If it return something else such as PlayerState, some of the functions in this plugin will be broken. There are 2 ways to fix this, change your avatar actor to the character or change the code in my plugin to adapt with your \u0026ldquo;Avatar Actor\u0026rdquo; version. 1.1.1 Compatibility UE 5.4 ‚Äì 5.5 Bug Fixes feat: Add UActionPass_ActivateGenericAbility to activate normal UGameplayAbility. UActionPass_ActivateAbility will only be able to activate ability derived from UContextAbility class. 1.1 Compatibility UE 5.4 ‚Äì 5.5 Bug Fixes fix: Support multiple damage notifies in a single frame.\nPreviously only one notify could trigger per frame; this update ensures all overlapping notifies are processed correctly. 1.0 Compatibility UE 5.4 ‚Äì 5.5 New Features feat: Initial release of ComboGraph. Visual graph editor for designing combo sequences. Directional branching, animation timing, and input buffering. Runtime component for execution in both C++ and Blueprints. Includes demo map: L_Demo. ","permalink":"https://teambaconn.github.io/plugin/combo-graph/changelog/","summary":"\u003ch2 id=\"113-latest-on-fab\"\u003e1.1.3 (Latest on FAB)\u003c/h2\u003e\n\u003ch4 id=\"compatibility\"\u003eCompatibility\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003eUE \u003ccode\u003e5.4\u003c/code\u003e ‚Äì \u003ccode\u003e5.6\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"bug-fixes\"\u003eBug Fixes\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003efeat\u003c/strong\u003e: Allow users to make custom ComboGraphAsset (inherit from \u003ccode\u003eUComboGraphAsset\u003c/code\u003e) and be able to create the Combo Graph from their custom base class.\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch2 id=\"112\"\u003e1.1.2\u003c/h2\u003e\n\u003ch4 id=\"compatibility-1\"\u003eCompatibility\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003eUE \u003ccode\u003e5.4\u003c/code\u003e ‚Äì \u003ccode\u003e5.6\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"bug-fixes-1\"\u003eBug Fixes\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003efix\u003c/strong\u003e: Fix crash when activating context ability which the ASC is on the PlayerState not the Character / Pawn.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003enote\u003c/strong\u003e: Keep in mind, \u003ccode\u003eGetAvatarActor\u003c/code\u003e function of the ASC must return the Character / Pawn. If it return something else such as \u003cstrong\u003ePlayerState\u003c/strong\u003e, some of the functions in this plugin will be broken.\nThere are 2 ways to fix this, change your avatar actor to the character or change the code in my plugin to adapt with your \u0026ldquo;Avatar Actor\u0026rdquo; version.\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch2 id=\"111\"\u003e1.1.1\u003c/h2\u003e\n\u003ch4 id=\"compatibility-2\"\u003eCompatibility\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003eUE \u003ccode\u003e5.4\u003c/code\u003e ‚Äì \u003ccode\u003e5.5\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"bug-fixes-2\"\u003eBug Fixes\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003efeat\u003c/strong\u003e: Add UActionPass_ActivateGenericAbility to activate normal UGameplayAbility. UActionPass_ActivateAbility will only be able to activate\nability derived from UContextAbility class.\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch2 id=\"11\"\u003e1.1\u003c/h2\u003e\n\u003ch4 id=\"compatibility-3\"\u003eCompatibility\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003eUE \u003ccode\u003e5.4\u003c/code\u003e ‚Äì \u003ccode\u003e5.5\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"bug-fixes-3\"\u003eBug Fixes\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003efix\u003c/strong\u003e: Support multiple damage notifies in a single frame.\u003cbr\u003e\nPreviously only one notify could trigger per frame; this update ensures all overlapping notifies are processed correctly.\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch2 id=\"10\"\u003e1.0\u003c/h2\u003e\n\u003ch4 id=\"compatibility-4\"\u003eCompatibility\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003eUE \u003ccode\u003e5.4\u003c/code\u003e ‚Äì \u003ccode\u003e5.5\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"new-features\"\u003eNew Features\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003efeat\u003c/strong\u003e: Initial release of ComboGraph.\n\u003cul\u003e\n\u003cli\u003eVisual graph editor for designing combo sequences.\u003c/li\u003e\n\u003cli\u003eDirectional branching, animation timing, and input buffering.\u003c/li\u003e\n\u003cli\u003eRuntime component for execution in both C++ and Blueprints.\u003c/li\u003e\n\u003cli\u003eIncludes demo map: \u003ccode\u003eL_Demo\u003c/code\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e","title":"Changelog"},{"content":"‚ö†Ô∏è Usage Modes ‚Äì Read Before Using This plugin supports two modes, and setup/implementation may differ depending on the mode. These differences will be clearly annotated in the documentation as GAS or Generic use cases:\nChoose the mode that best fits your project setup.\r\u0026nbsp;\rGAS Mode (Recommended):\n‚úÖ Works well with Gameplay Ability System\n‚úÖ Full feature support\n‚úÖ Built-in replication via GAS Generic Mode:\n‚úÖ Full feature support\n‚ùå No replication support ‚Äì manual replication is required if needed Node Types Root Node Root node is the starting point of the graph. When the graph resets, it returns to this node.\nExecution Node Used to perform actions, such as playing animations, consuming mana, or triggering gameplay effects.\nEach Execution Node can contain multiple Action Passes. Passes are executed from top to bottom. If any pass fails, execution stops and follows the Fail output pin. Creating a Custom Action Pass Create a custom Action Pass by inheriting from UComboActionPass.\nExamples:\nC++: UComboActionPass_PlayMontage Blueprint: CAP_Generic_Attack Tip: CAP stands for Combo Action Pass. It\u0026rsquo;s a useful prefix for filtering in the editor.\nCondition Branch Acts like an IF statement. The node will evaluates one or more Condition Passes using logical operators (e.g., AND, OR) and determines which path to take.\nCreating a Custom Condition Pass Create a custom Condition Pass by inheriting from UComboConditionPass.\nExamples:\nC++: UComboConditionPass_EnoughStat Blueprint: CCP_ConditionExample Tip: CCP stands for Combo Condition Pass.\n‚ö†Ô∏è Condition Passes must only call const functions. They should not change game state. If you need to change state or trigger events, use an Execution Node instead.\nInput Node Waits for a specific player input before continuing the combo.\nYou define input types using Gameplay Tags and can integrate with the Enhanced Input System for more advanced input handling.\nHow to Create a New Input Define a GameplayTag that starts with ComboGraph.Input, e.g., ComboGraph.Input.HeavyAttack.\nYou can manage your tags in a DataTable using FGameplayTagTableRow.\nCreate an Input Action if you\u0026rsquo;re using the Enhanced Input System. (If you are not using Enhanced Input System, then you can skip this step)\nIn your PlayerController or Character, bind the input event and trigger the combo graph using the tag you defined.\nFor more advanced control, you can add direction to the tag.\nExample: ComboGraph.Input.HeavyAttack.B can represent a backward heavy attack.\nThis will match input nodes with ComboGraph.Input.HeavyAttack.B or its parent ComboGraph.Input.HeavyAttack. How to use directional input Reset Node Resets the graph and returns execution to the Root Node.\nPortal / Portal Jump Node These nodes allow for function-like behavior within the graph.\nUse them to simplify complex graphs or to jump to specific locations in the graph based on gameplay logic.\nHow to Use Create a Portal Node and assign it a unique Gameplay Tag. Use a Portal Jump Node to jump to that tag. If the specified tag doesn\u0026rsquo;t exist, execution fails and returns to the Root Node. ‚ö†Ô∏è Only one Portal Node per tag is allowed. However, you can have multiple Jump Nodes referencing the same tag.\n","permalink":"https://teambaconn.github.io/plugin/combo-graph/documentation/","summary":"\u003ch1 id=\"-usage-modes--read-before-using\"\u003e‚ö†Ô∏è Usage Modes ‚Äì Read Before Using\u003c/h1\u003e\n\u003cp\u003eThis plugin supports \u003cstrong\u003etwo modes\u003c/strong\u003e, and setup/implementation may differ depending on the mode. These differences will be clearly annotated in the documentation as \u003cstrong\u003eGAS\u003c/strong\u003e or \u003cstrong\u003eGeneric\u003c/strong\u003e use cases:\u003c/p\u003e\n\r\n\r\n\r\n\r\n\r\n\u003cspan style=\"\r\n    background-color: #FFD700; \r\n    padding: 4px 2px 4px 8px; \r\n    margin: 0px; \r\n    border-radius: 2px;\r\n    font-size: 95%;\r\n\"\u003e\r\n  \u003cspan style=\"\r\n    color: black;\r\n    font-weight: ;\r\n  \"\u003e\r\n    Choose the mode that best fits your project setup.\r\n  \u003c/span\u003e\r\n\u003c/span\u003e\u0026nbsp;\r\n\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eGAS Mode\u003c/strong\u003e (Recommended):\u003cbr\u003e\n‚úÖ Works well with Gameplay Ability System\u003cbr\u003e\n‚úÖ Full feature support\u003cbr\u003e\n‚úÖ Built-in replication via GAS\u003c/li\u003e\n\u003c/ul\u003e\n\u003cbr /\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eGeneric Mode\u003c/strong\u003e:\u003cbr\u003e\n‚úÖ Full feature support\u003cbr\u003e\n‚ùå \u003cstrong\u003eNo replication support\u003c/strong\u003e ‚Äì manual replication is required if needed\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"node-types\"\u003eNode Types\u003c/h1\u003e\n\u003chr\u003e\n\u003ch2 id=\"root-node\"\u003eRoot Node\u003c/h2\u003e\n\u003cp\u003eRoot node is the starting point of the graph. When the graph resets, it returns to this node.\u003c/p\u003e","title":"Documentation"},{"content":"\r- You can watch the tutorial video and follow the text version below.\n1. Prepare your ACharacter Make sure your Character blueprint or C++ has these components added:\nAnimationDrivenComponent ‚Äì For listening to animation montage data and signaling it to other systems (e.g., gameplay abilities) ComboManagerComponent ‚Äì For managing the combo graph IMPORTANT!!!\r\u0026nbsp;\rFor GAS Users\r\u0026nbsp;\rMake sure your Character has AbilitySystemComponent and is derived from UContextAbilitySystemComponent.\nSee ComboBasicCharacter.h for a default GAS implementation.\nOr you can read the GAS installation guide here: Installation doc\nFor Generic Users\r\u0026nbsp;\rAdd the GameplayTasks component to your Character\u0026rsquo;s Blueprint to use GameplayTasks.\n2. Create a Combo Graph Create the Combo Graph Asset. This is where combat designers primarily work.\nIt stores the full combo tree with branching and variations. Right-click on the graph to open the node creation panel.\nFocus on:\nInput Branch (green node) Execution Node (red node) More node types are covered in the üßä Combo Graph Nodes section.\n3. Create an Input Branch and connect the Start Combo pin from the Root node to the Input pin of the new branch.\nThis marks the entry point of your combo.\nClick the node and configure it using the Node Data panel.\nSpecify which input (via Gameplay Tags) triggers the next combo step.\nTags must begin with ComboGraph.Input (e.g., ComboGraph.Input.Attack). 5. Create an Execution Node and connect it to the previous Input Branch. Add an Execution Pass (e.g., Play Montage) and assign your chosen animation montage. 7. Repeat steps 4‚Äì6 to chain additional combo steps:\nRoot ‚Üí Input ‚Üí Execute (Combo 1) ‚Üí Input ‚Üí Execute (Combo 2) ‚Üí ‚Ä¶\n3. Prepare Input How to create a new input and hook it to the Combo Graph\n4. Setup Combo Graph on Your Character Open your ComboManagerComponent settings and add a default Combo Graph: Select your Combo Graph asset. Select the appropriate graph instance: IMPORTANT!!!\r\u0026nbsp;\rFor GAS Users\r\u0026nbsp;\rUse ComboGraphInstance_ASC\nFor Generic Users\r\u0026nbsp;\rUse ComboGraphInstance_Generic\nGrant combo graph in runtime Swap between combo graphs There can only be one combo graph activated per Character / Combo Manager. To switch the active combo graph in runtime you can use the node below.\nüí° Tip:\nGetCurrentInstance return the current instance but you can add an offset index +1 or -1 to grab the left or right graph instance in the list. If you need to grab an instance with a specific graph asset use GetComboGraphInstanceByAsset function 5. Prepare Your Montage We use animation-driven design: static data is stored in animations and triggered via Notifies.\nOpen the montage used in your Combo Graph. 2. Add these three Notify States:\nBlock Proceed Graph: Prevents combo continuation until it\u0026rsquo;s done. Input Window: Enables player input capture for the next combo. Damage Notify: Triggers hitboxes. 3. Use plugin-provided Notify States:\nHitbox Detection (works on all modes):\nADNS_Damage_LeftFoot ADNS_Damage_LeftSword ‚Ä¶ IMPORTANT!!!\r\u0026nbsp;\rFor GAS Users\r\u0026nbsp;\rANS_GAS_InputWindow ANS_GAS_ComboWindow For Generic Users\r\u0026nbsp;\rANS_Generic_InputWindow ANS_Generic_ComboWindow 6. Implement Hitbox \u0026amp; Damage The plugin provides built-in collision detection for both GAS and non-GAS setups.\nIMPORTANT!!!\r\u0026nbsp;\rFor GAS Users\r\u0026nbsp;\rUse the GA_CombatAbility_Base and override the OnHit function to handle hit events.\nFor Generic Users\r\u0026nbsp;\rRefer to CBP_BasicComboCharacter ‚Üí BeginPlay for a complete example.\nIt\u0026rsquo;s the same as when using GAS but instead of using AbilityTask, you‚Äôll implement hit logic using GameplayTask from your character or component blueprint.\n","permalink":"https://teambaconn.github.io/plugin/combo-graph/quick-start/","summary":"\u003cdiv style=\"position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;\"\u003e\r\n          \u003ciframe allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen=\"allowfullscreen\" loading=\"eager\" referrerpolicy=\"strict-origin-when-cross-origin\" src=\"https://www.youtube.com/embed/oyybI_qCwcw?autoplay=0\u0026amp;controls=1\u0026amp;end=0\u0026amp;loop=0\u0026amp;mute=0\u0026amp;start=0\" style=\"position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;\" title=\"YouTube video\"\u003e\u003c/iframe\u003e\r\n        \u003c/div\u003e\n\u003cp\u003e\u003cem\u003e- You can watch the tutorial video and follow the text version below.\u003c/em\u003e\u003c/p\u003e\n\u003ch2 id=\"1-prepare-your-acharacter\"\u003e1. Prepare your ACharacter\u003c/h2\u003e\n\u003cp\u003eMake sure your Character blueprint or C++ has these components added:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eAnimationDrivenComponent\u003c/code\u003e ‚Äì For listening to animation montage data and signaling it to other systems (e.g., gameplay abilities)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eComboManagerComponent\u003c/code\u003e ‚Äì For managing the combo graph\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\r\n\r\n\r\n\r\n\r\n\u003cspan style=\"\r\n    background-color: red; \r\n    padding: 4px 2px 4px 8px; \r\n    margin: 0px; \r\n    border-radius: 2px;\r\n    font-size: 95%;\r\n\"\u003e\r\n  \u003cspan style=\"\r\n    color: white;\r\n    font-weight: bold;\r\n  \"\u003e\r\n    IMPORTANT!!!\r\n  \u003c/span\u003e\r\n\u003c/span\u003e\u0026nbsp;\r\n\n\u003cbr\u003e\n\u003cbr\u003e\n\r\n\r\n\r\n\r\n\r\n\u003cspan style=\"\r\n    background-color: #FFD700; \r\n    padding: 4px 2px 4px 8px; \r\n    margin: 0px; \r\n    border-radius: 2px;\r\n    font-size: 95%;\r\n\"\u003e\r\n  \u003cspan style=\"\r\n    color: black;\r\n    font-weight: bold;\r\n  \"\u003e\r\n    For GAS Users\r\n  \u003c/span\u003e\r\n\u003c/span\u003e\u0026nbsp;\r\n\u003c/p\u003e","title":"Quick Start"},{"content":"This post gathers some of the most useful resources I‚Äôve come across ‚Äî from general Unreal knowledge and multiplayer guides to the Gameplay Ability System (GAS) and advanced debugging techniques. Whether you‚Äôre a beginner or deep into production, these links can save you hours of searching.\nüêû Git Knowledge Git for Unreal Engine üí° Unreal General Knowledge Deep Unreal C++ topics with code demos: YouTube ‚Äî enigma_dev Unreal Notes (information is not fully documented but often golden if you dig deep): ikrima.dev UE4 Guide Unreal Knowledge Base (mostly in Chinese, includes interesting topics about UnLua framework): UE5 Wiki Understanding Unreal Engine cycles and loops: YouTube ‚Äî Unreal Engine Cycles/Loops Smart pointers: Epic - All about Soft and Weak pointers Modules: Epic - Unreal Engine\u0026rsquo;s C++ Modules üåê Multiplayer Knowledge A great starting point for multiplayer basics: Multiplayer Starter Knowledge General multiplayer tips and tricks (must read): Wizardcell Multiplayer Tips üó°Ô∏è Gameplay Ability System (GAS) The ultimate GAS knowledge base: GAS Documentation by tranek Full setup example project: Narxim-GAS-Example üêû Debugging Advanced multi-purpose debugging plugin (works well with GAS): Cog Debugging Plugin Advanced debugging techniques using an IDE: Epic Games Advanced Debugging Tutorial üß∞ Debugging Tip: Paste the following lines into Rider‚Äôs variable watcher (exclude the comments) for quick insights during breakpoints:\n// Check if the breakpoint is on the client or server {,,UnrealEditor-Engine.dll}::GPlayInEditorContextString // Display the current frame count {,,UnrealEditor-Core.dll}::GFrameCounter // View the current game configuration {,,UnrealEditor-Core.dll}::GConfig CommonUI Different controller icon support ","permalink":"https://teambaconn.github.io/unreal-post/external-resources/","summary":"A collection of valuable resources for Unreal Engine developers, covering general knowledge, multiplayer, GAS, and advanced debugging tools","title":"[Unreal] External Knowledge"},{"content":"What is animation driven? Animation driven is a term usually refers to systems or mechanics where some aspects in a system are controlled directly by animations‚Äîrather than calculated through physics or pure code logic.\nAnimations essentially authorize the system to perform certain actions in-game such as moving, dealing damage, spawning hitboxes, performing grab attacks, picking up items\u0026hellip;\nIf the animation gets interrupted, most of those events simply won‚Äôt trigger. I say most because sometimes, for balance reasons, a game might choose to ignore the interruption and still execute the event anyway.\nThe difference between animation-driven and logic-driven systems It all comes down to one question: Who's making the decision?\nLet‚Äôs take a simple AOE skill as an example and compare two different implementations:\nLogic-driven system:\n‚ÄúThe system plays the animation and drives the logic itself.‚Äù\nIn this setup, the skill system plays the animation, then waits for 0.4s before telling the damage system to apply AOE damage.\nAnimation-driven system:\n‚ÄúThe animation feeds data into the system and trigger the logics‚Äù\nHere, the skill system still plays the animation, but instead creating a timer to wait for 0.4s, it waits for the animation to notify the system when to apply damage, and how large / powerful the AOE should be. Usually for static data that doesn\u0026rsquo;t need to change in runtime (dynamic), it can be stored in the animation data for beter and centralized visualization (see the image below).\nWhen should you use an animation-driven system? TL;DR: If you\u0026rsquo;re making a Souls-like game just use it.\nYou should consider using animation-driven systems when:\nYou\u0026rsquo;re aiming for realistic gameplay where animation and logic need to be tightly synced Your animations vary in speed and that variation affects timing of gameplay events You want game designers to balance and tweak things visually, without the longgg config \u0026amp; test loop Honestly, creating new content in an animation-driven system is often much easier. You can see exactly what\u0026rsquo;s happening, and tweaking animations gives you immediate feedback on how the gameplay feels.\nEven better, moving some logic into animation assets lets game designers create and test content quickly, without needing a programmer to step in. That means faster iteration and more time for devs to focus on deeper systems or fixing that one annoying bug that only happens on Friday üòÖ.\nAnimation-Driven System in Unreal Implementation The image above is an example of how I think an animation-driven system should be implemented for Gameplay Ability System in Unreal.\nFor other systems, you can use the same approach, it just in different by names.\nI\u0026rsquo;ve annotated the steps in the image, from start (ActivateAbility) to end (EndAbility). Here\u0026rsquo;s a breakdown:\nThe ability gets activated and plays a montage.\nUse the PlayMontageAndWait ability task from GAS as it already has built-in delegates and handles replication for multiplayer. The ability waits for one of the relevant montage events (OnCompleted, OnInterrupted, OnBlendOut) to end or cancel the ability. While the montage plays, any animation notify it hits will send data to a custom component called AnimationDrivenProxyComponent.\nThat component then broadcasts the OnDataReceiveDelegate delegate. The ability task binds to OnDataReceiveDelegate delegate in the AnimationDrivenProxyComponent to listen for notify data.\nMake sure it only listens to relevant data‚Äîsince multiple montages might be playing at once.\nFor example: if your animation-driven ability plays Montage A, then the task should only react to notify data coming from Montage A. Once the ability task receives the notify data, it drives the logic of the ability accordingly. Notes Animation Notifies and Notify States are STATELESS as they\u0026rsquo;re shared across animation instances, so only use them for static data.\nIf you need to listen to NotifyState tick functions, don‚Äôt flood AnimationDrivenProxyComponent with updates.\nInstead, only send NotifyBegin and NotifyEnd‚Äîlet the ability task handle ticking if needed. It‚Äôs more efficient that way.\nOn dedicated servers (not listen servers), skeletal meshes don\u0026rsquo;t tick, meaning no animation plays on the server-side.\nThus, if you‚Äôre spawning a hitbox on a moving socket (like a sword swing), it might just float there on the server.\nTo fix this, you‚Äôll need to force the mesh to tick pose during montage playback. Add this in your ACharacter constructor or BeginPlay:\n#ifdef WITH_SERVER_CODE GetMesh()-\u0026gt;VisibilityBasedAnimTickOption = EVisibilityBasedAnimTickOption::OnlyTickMontagesAndRefreshBonesWhenPlayingMontages; #else // Default client setting GetMesh()-\u0026gt;VisibilityBasedAnimTickOption = EVisibilityBasedAnimTickOption::OnlyTickPoseWhenRendered; #endif A notify placed at the very beginning of the animation is not guaranteed to fire immediately. If you do something like: Play Animation A ‚Üí Expect Notify to fire ‚Üí Check for that event in the same frame ‚Ä¶it might fail, because the notify may not trigger until the next animation tick. Solution: If the logic must happen right after playing the animation, don‚Äôt rely on the notify. Trigger it manually after playing the animation, or delay your logic by 1 frame. The notify that you put in the end will NOT be guaranteed to hit, since the animation could be interupted or blend out too early. Only Notify State will hit end if your animation finishes early (only if the NotifyBegin has already triggered). ","permalink":"https://teambaconn.github.io/unreal-post/animation-driven/","summary":"A general overview of animation-driven systems in game development, along with practical tips and implementation strategies for building them using GAS.","title":"[Unreal] Animation Driven System"},{"content":"‚ö†Ô∏è Prerequisites These tips apply to Unreal Engine 5 and later. If you\u0026rsquo;re working with an older version, the behavior might be different. Feel free to reach out if any of my information is incorrect or misleading. I only mention tips that I believe are not well-documented online. Replicated Tags 1. AddReplicatedLooseGameplayTag (or remove) does not modify tags on the caller side For example, if you add replicated tags on the server, only the clients will receive them (through MinimalReplicationTags replication), but the tag will NOT be added on the server itself.\nIf you want to add or remove the tag on the server and also replicate it to clients, use:\nUAbilitySystemBlueprintLibrary::AddLooseGameplayTag UAbilitySystemBlueprintLibrary::RemoveLooseGameplayTag 2. Do NOT use AddLooseGameplayTag or RemoveLooseGameplayTag on replicated tags to modify them locally (unless you\u0026rsquo;re the authoritative server) Adding or removing a loose gameplay tag on the client will eventually be overridden by the replicated version from the server.\nExample: You add Tag.Example locally on the client five times. On the server, you call AddReplicatedLooseGameplayTag with Tag.Example once. The client‚Äôs tag count gets overridden when the server replicates MinimalReplicationTags. The server does not care how many times the client added the tag locally; only the replicated state matters. Replication Stage Client State Server State Before Replication 5 1 Expected After Replication 6 1 Actual After Replication 1 (Overridden) 1 Workaround: To make the server respect locally added tags, you can create a new tag: Tag.Example.Replicated.\nUse this tag for replication (AddReplicatedLooseGameplayTag, ability tags, etc.). Use Tag.Example for locally added tags. This separation prevents the server from overriding local tags. Specify Tag Prefixes for Blueprint Users In most projects, there are many tags, but certain systems only need to handle a specific group of them. For example, input tags only need to consider tags beginning with ComboGraph.Input.\nBy enforcing tag prefixes, you:\nReduce the risk of selecting the wrong tag. Keep tags organized and readable. Restricting Tags in Blueprints You can enforce tag prefixes by using arbitrary prefixes in different data structures such as FGameplayTag, TArray, and TMap. However, this restriction only works in Blueprints‚ÄîC++ does not enforce it.\nExample Usage: // Restrict TArray tags using Categories UPROPERTY(EditAnywhere, meta = (Categories = \u0026#34;General.Input\u0026#34;)) TArray\u0026lt;FGameplayTag\u0026gt; InputTags; // Restrict TMap tags using GameplayTagFilter UPROPERTY(EditAnywhere, meta = (GameplayTagFilter = \u0026#34;General.SetByCaller\u0026#34;)) TMap\u0026lt;FGameplayTag, float\u0026gt; SetByCallerMagnitudes; // Restrict function parameters (must not be a reference parameter) UFUNCTION(BlueprintCallable, Meta = (GameplayTagFilter = \u0026#34;General.Input\u0026#34;)) void ExampleFunc(FGameplayTag Input); By using these metadata settings, you can improve organization and enforce structured tag usage in your Blueprint systems.\nSerialize TMap\u0026lt;FGameplayTag, float\u0026gt; or any TMap for replication By default TMap is not supported for sending through network. In my game, I have the need to send the TMap\u0026lt;FGameplayTag, float\u0026gt; Params to the clients so I have to do my own serialization. This is the same way GAS use to replicate tag counts.\nUSTRUCT(Blueprintable) struct FReplicatedMapWrapper { GENERATED_USTRUCT_BODY() virtual bool NetSerialize(FArchive\u0026amp; Ar, class UPackageMap* Map, bool\u0026amp; bOutSuccess) override; public: UPROPERTY(BlueprintReadWrite) TMap\u0026lt;FGameplayTag, float\u0026gt; Params; }; template\u0026lt;\u0026gt; struct TStructOpsTypeTraits\u0026lt;FReplicatedMapWrapper\u0026gt; : public TStructOpsTypeTraitsBase2\u0026lt;FReplicatedMapWrapper\u0026gt; { enum { WithNetSerializer = true, }; }; bool FReplicatedMapWrapper::NetSerialize(FArchive\u0026amp; Ar, class UPackageMap* Map, bool\u0026amp; bOutSuccess) { constexpr int32 CountBits = MAX_ELEMENT_COUNT; constexpr int32 MaxCount = ((1 \u0026lt;\u0026lt; CountBits) - 1); if (Ar.IsSaving()) { int32 Count = Params.Num(); if (Count \u0026gt; MaxCount) { UE_LOG(LogTemp, Error, TEXT(\u0026#34;FReplicatedMapWrapper::NetSerialize: Too many params (%d) for replication. Clamping to %d.\u0026#34;), Count, MaxCount); Count = MaxCount; } Ar.SerializeBits(\u0026amp;Count, CountBits); for (auto\u0026amp; It : Params) { FGameplayTag Tag = It.Key; float Value = It.Value; Tag.NetSerialize(Ar, Map, bOutSuccess); Ar \u0026lt;\u0026lt; Value; if (--Count \u0026lt;= 0) { break; } } } else { int32 Count = 0; Ar.SerializeBits(\u0026amp;Count, CountBits); Params.Empty(); while (Count-- \u0026gt; 0) { FGameplayTag Tag; float Value = 0.f; Tag.NetSerialize(Ar, Map, bOutSuccess); Ar \u0026lt;\u0026lt; Value; Params.Add(Tag, Value); } } return true; } I hope these insights help you avoid common pitfalls and improve your workflow! If you have any questions or additional tips, feel free to reach out. üöÄ\n","permalink":"https://teambaconn.github.io/unreal-post/gameplay-tag/","summary":"Gotcha tips you might not know when using Gameplay Tags with GAS","title":"[Unreal] Using Gameplay Tags with GAS"},{"content":"About Me My name is Nguyen Lam Tuong (Bacon) I am based in Ho Chi Minh City, Vietnam I have a bachelor\u0026rsquo;s degree in Computer Science from HCM University of Science Check out my üü¶ LinkedIn for the latest updates on my professional profile. Technical Skills Game AI, Gameplay Programming, Tool / Editor Programming Multiplayer Programming Unreal Engine, Unity C++, C#, Lua, Java, Javascript 3D Math, Linear Algebra Web \u0026amp; App Fullstack Development Published Games Sipher Odyssey - Cross Platform\rFramework: Unreal Engine\nResponsibility: Game Engineer\nWebsite: Sipher Odyssey\nDemon Hunter - Mobile\rFramework: BlockmanGO Engine\nResponsibility: Product Owner, Full-stack Developer\nPersonal / Gamejam Projects Most of my games are available on Itch.io\nYou can explore more games from my old portfolio\nProject Brawl - UE5 / PC - Console\rFramework: Unreal Engine\nResponsibility: Solo Developer\nCombat system - UE5 / PC\rFramework: Unreal Engine\nResponsibility: Solo Developer\nMagic Typer - Web / Mobile\rFramework: Unity\nResponsibility: Solo Developer\nFarm Fortune - Web\rFramework: Unity\nResponsibility: Solo Developer\nHellevator - Web / Mobile\rFramework: Unity\nResponsibility: Solo Developer\nChess Factorio - Web\rFramework: Unity\nResponsibility: Solo Developer\nNon-game projects Stylix - Mobile App\rStylix is a mobile app that allows users to virtually try on any clothes before purchase. We accurately analyze the body of users, allowing them to try on any clothes at any time and anywhere. By using state-of-the-art models, our technology can map 2D images of clothes onto the user\u0026rsquo;s body despite their unique shape in no time and at low cost.\nChannel: Youtube Project detail: Milanote FindMe - Web App\rFindMe provides a service that allows filtering of running athletes\u0026rsquo; images based on the athlete\u0026rsquo;s bib number (BIB) and face recognition. Runners can access the product\u0026rsquo;s website after the event finishes, upload their face image, or enter their BIB number to retrieve all of the photos containing their faces or bib in the race.\nProject detail: Milanote ","permalink":"https://teambaconn.github.io/posts/portfolio/","summary":"I am a game developer specializing in systems and gameplay programming in Unreal and Unity, focused on writing efficient, clean code and tackling new challenges in game development.","title":"Tuong Nguyen - Game Developer Portfolio"}]