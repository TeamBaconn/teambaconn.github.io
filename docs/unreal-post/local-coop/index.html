<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[Unreal] Splitscreen Multiplayer Guide | BaconGameDev's Blog</title>
<meta name=keywords content="game,unreal,coop,multiplayer"><meta name=description content="A deep dive into the hidden challenges of building splitscreen multiplayer in Unreal Engine"><meta name=author content="Tuong Nguyen, aka Bacon"><link rel=canonical href=https://teambaconn.github.io/unreal-post/local-coop/><link crossorigin=anonymous href=/assets/css/stylesheet.045e2853f9032985daf780ff5a3c48c1be492a0896a3fedf1e6a6e5248f93b3a.css integrity="sha256-BF4oU/kDKYXa94D/WjxIwb5JKgiWo/7fHmpuUkj5Ozo=" rel="preload stylesheet" as=style><link rel=icon href=https://teambaconn.github.io/logo.png><link rel=icon type=image/png sizes=16x16 href=https://teambaconn.github.io/logo16.png><link rel=icon type=image/png sizes=32x32 href=https://teambaconn.github.io/logo32.png><link rel=apple-touch-icon href=https://teambaconn.github.io/apple-touch-icon.png><link rel=mask-icon href=https://teambaconn.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://teambaconn.github.io/unreal-post/local-coop/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-1FTRRSKLPF"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-1FTRRSKLPF")}</script><meta property="og:url" content="https://teambaconn.github.io/unreal-post/local-coop/"><meta property="og:site_name" content="BaconGameDev's Blog"><meta property="og:title" content="[Unreal] Splitscreen Multiplayer Guide"><meta property="og:description" content="A deep dive into the hidden challenges of building splitscreen multiplayer in Unreal Engine"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="unreal-post"><meta property="article:published_time" content="2025-12-02T01:34:25+07:00"><meta property="article:modified_time" content="2025-12-02T01:34:25+07:00"><meta property="article:tag" content="Game"><meta property="article:tag" content="Unreal"><meta property="article:tag" content="Coop"><meta property="article:tag" content="Multiplayer"><meta property="og:image" content="https://teambaconn.github.io/posts/local-coop/splitscreen.gif"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://teambaconn.github.io/posts/local-coop/splitscreen.gif"><meta name=twitter:title content="[Unreal] Splitscreen Multiplayer Guide"><meta name=twitter:description content="A deep dive into the hidden challenges of building splitscreen multiplayer in Unreal Engine"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Unreal-Posts","item":"https://teambaconn.github.io/unreal-post/"},{"@type":"ListItem","position":2,"name":"[Unreal] Splitscreen Multiplayer Guide","item":"https://teambaconn.github.io/unreal-post/local-coop/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[Unreal] Splitscreen Multiplayer Guide","name":"[Unreal] Splitscreen Multiplayer Guide","description":"A deep dive into the hidden challenges of building splitscreen multiplayer in Unreal Engine","keywords":["game","unreal","coop","multiplayer"],"articleBody":"Abstract It‚Äôs been a while since my last blog post! Recently, I‚Äôve been fully focused on developing my game Project Brawl - a beat ‚Äôem up with local co-op and multiplayer support. And as the title suggests, I ran into quite a few headaches while developing the local co-op features.\nAlthough Unreal technically supports splitscreen out of the box, there‚Äôs almost no proper documentation from Epic explaining how to actually use it in a real project. Every tutorial out there just says something like:\n‚ÄúGo to Project Settings, enable Use Splitscreen, and call CreateLocalPlayer().‚Äù\nSo I thought, ‚ÄúLocal multiplayer? Easy! Let‚Äôs do it!‚Äù ‚Äî and then spent weeks struggling to make Unreal‚Äôs already supported feature work as expected. Hopefully, by sharing what I‚Äôve learned here, I can save you a lot of that time and frustration and help you get your game local-coop ready much faster üòÑ\n‚öôÔ∏è Random guides üß± Definitions Before diving in, let‚Äôs clarify the key terminology you‚Äôll encounter:\nFInputDeviceId\rAn ID that identifies a specific input device (keyboard, gamepad, etc.) FPlatformUserId\rAn ID that identifies a LocalPlayer ControllerId\rAn old int32 ID used to identify a LocalPlayer Epic is replacing this with FPlatformUserId in future versions Important: Do not confuse this with PlayerController Local Player\rStores information about a ‚Äúlocal‚Äù player on your game‚Äôs running machine Contains all the InputDeviceIds connected to that player and a FPlatformUserId to identify itself Note: This is not the same as PlayerController A LocalPlayer does not guarantee to have a PlayerController and vice versa (depends on the context) Primary Player\rThe first local player created in the game Different on each client in a multiplayer game Relationship hierarchy:\nLocalPlayer ‚Üí PlayerController ‚Üí Pawn üóø Create / Remove Local Player All of the local players are stored in the GameInstance. To create and remove a local player it‚Äôs quite simple as calling function\nULocalPlayer* CreateLocalPlayer(int32 ControllerId, FString\u0026 OutError, bool bSpawnPlayerController); ULocalPlayer* CreateLocalPlayer(FPlatformUserId UserId, FString\u0026 OutError, bool bSpawnPlayerController); // Becareful when using this, as you can accidentally remove the primary local player bool RemoveLocalPlayer(ULocalPlayer * ExistingPlayer); Notes: If you have no clue how to get the ControllerId or UserId and just want to spawn a new player, just use ControllerId -1. It should automatically create a new LocalPlayer for you. You should always spawn the player controller (by setting bSpawnPlayerController = true). There are no reason you want to spawn the LocalPlayer without PlayerController since it will automatically spawn a PlayerController for you after switching level. The only reason I can see you doing this is: It‚Äôs middle of the game, you still want to create a LocalPlayer but not actually doing anything because the game is in progress. And it will automatically spawn the PlayerController after the game ends and switch level. But why letting that, instead just wait until the game finishes? It will create more unexpected behaviors (believe me, I go through the hard way) ü™ü Widgets in Local Splitscreen Working with widgets in local splitscreen can be tricky if you‚Äôre only familiar with single-player games. The key concept to understand is: Each widget is owned by a LOCAL PLAYER and only that player can interact with it\rAdding Widget to Global \u0026 Local viewport Unreal provides 2 functions to add widgets to the screen:\nUUserWidget::AddToViewport(int32 ZOrder)\nAdds the widget to the global viewport (overlaps all splitscreens when the screen is split) Use this for global widgets like: Pause menus Main menus Global announcements UUserWidget::AddToPlayerScreen(int32 ZOrder)\nAdds the widget to a specific local player‚Äôs viewport Which player‚Äôs screen receives the widget depends on the OwningPlayer (PlayerController) you pass when creating the widget Use this for player-specific widgets like: Player HUD Player‚Äôs local pause menu / settings (like in Lyra) ‚ö†Ô∏è Important: Always assign the OwningPlayer when creating widgets. If left blank, Unreal automatically assigns it to the first Local Player (primary player), or to itself if called from within a PlayerController (see UUserWidget::CreateWidgetInstance for details). While this works for single-player games, local co-op games need deterministic ownership to function correctly.\nWidgetComponent When creating character health bars, you‚Äôll likely use WidgetComponent to display widgets in either World Space or Screen Space. While both look similar, they behave very differently in local co-op:\nWorld Space:\nRenders the widget on a mesh Visible to any players seeing that mesh Screen Space:\nWidget behaves as if in world space, but is added to A OWNING PLAYER‚ÄôS SCREEN Only visible to the owning player Problem: Split Screen UI widget Component Showing only in Player 0 screen.\nTL;DR: In a 4-player co-op game with Screen Space widgets, only the owning player will see other‚Äôs health bar and the other 3 players won‚Äôt see anything at all.\nEven worse: Unreal‚Äôs implementation is non-deterministic and changes between engine versions:\nUnreal 5.4 and below: The FIRST local player becomes the owner, meaning only the FIRST player sees the widget Unreal 5.5 and above: If the WidgetComponent is attached to a Pawn with a PlayerController, that player becomes the owner, meaning players can only see health bars on themselves, but cannot see others‚Äô health bars in their viewports. Solution: There are solutions on the internet that suggest that you should manually create each WidgetComponent for each local player and assign ownership accordingly. However, this approach is tedious, error-prone, and can break with engine updates. So instead, here‚Äôs my take:\nCreate an Actor Component that manages WidgetComponents to ensure all players see all Screen Space widgets, remaining stable across engine versions:\nOn Initialization:\nFind all WidgetComponents (Screen Space only) on the actor Store them in an ‚ÄúOriginal List‚Äù Disable each original by calling SetWidget(nullptr) For each LocalPlayer currently in the game, run the ‚ÄúLocalPlayer Added‚Äù logic below Listen for LocalPlayer added/removed events (from GameInstance) and run the respective logic When a LocalPlayer is Added:\nFor each WidgetComponent in the Original List: Create a new WidgetComponent instance Copy all settings from the original Call UWidgetComponent::SetOwnerPlayer() with the newly added LocalPlayer Store this cloned widget component for later cleanup When a LocalPlayer is Removed:\nFor each cloned widget component: Check if its OwnerPlayer matches the removed player If yes, destroy/remove that cloned widget Notes:\nEach widget component will now have N copies (where N = number of local players) It‚Äôs recommended that the widget components should hook into game events to update all copies simultaneously Main menu in splitscreen games Displaying the Menu This is different than ingame UIs since ingame UIs are displayed separately for each local players. For main menu UI, most games use one single screen to display the menu.\nProblem: If splitscreen is still active, the menu appears across multiple viewports, causing the screen to be split even though you only want one unified menu display. Solution: Use UGameplayStatics::SetForceDisableSplitscreen(GetWorld(), bDisable);. This forces the game to use one fullscreen viewport, allowing the menu to display correctly.\nDecide who can control and interact with the Menu Only the primary player can control the Menu Most games do this, and it‚Äôs the default behavior in Unreal. Every local players can control the Menu with the same pointer This easily becomes chaotic. I wouldn‚Äôt recommend this but if you still want to do this, use IPlatformInputDeviceMapper::Internal_ChangeInputDeviceUserMapping to map every input device of other local player to the primary local player. By doing that, every devices now have control of the menu. But make sure to returns it back once you‚Äôre in-game. Each local player has their own pointer\nThis is for educational purpose, please Nintendo, don‚Äôt sue my ass. You will see this mostly in character selection menu in fighting games where you have P1 and P2 pointer floating around to indicate that player‚Äôs champion selection. This is hard \u0026 kinna tedious to implement in my opinion. You will need: One shared widget containing all the actual menu buttons. A separate ‚Äúpointer widget‚Äù for each player, showing only their cursor and selection state. Pointer widgets mirror button positions/behavior from the shared widget (using CommonUI) and sync any shared actions (e.g., locking characters). Discorver new players You already know how to manually add or remove local players. But how do you let players themselves decide how many should join a session?\nThere are two main approaches.\n1. Let the Primary Player Register/Unregister Others This is the most simple way to implement.\nYou will have a button or a slider that allow the primary player to add and remove local players. As you create new local players, it will automatically paired with any unpaired input device for you.\n‚ö†Ô∏è But the binding is kinna random. If you have 4 gamepads connected and you only want 2 players in the session. Your players will have to figured out which in those 4 gamepads is currently controlling that 2 players.\n2. Let Input Devices Register Themselves This is what most party games do. A ‚ÄúJoin Game‚Äù screen shows all available player slots, and anyone can join simply by pressing a button on their controller. The game detects which device sent the input and registers a new player using that device. This way, each player instantly knows which gamepad they‚Äôre using and the host doesn‚Äôt need to manage it manually.\nProblem: Only the primary player has a PlayerController, which can listen for input and interact with the UI. So how do we detect input from unpaired devices that don‚Äôt have a controller yet?\nSolution: Unreal provides a delegate that fires whenever any connected device presses or releases a key. Lyra‚Äôs source code includes an example of this system here‚Äôs the basic idea:\n/** Delegate for overriding key input before it is routed to player controllers, returning true means it was handled by delegate */ DECLARE_DELEGATE_RetVal_OneParam(bool, FOverrideInputKeyHandler, FInputKeyEventArgs\u0026 /*EventArgs*/); You can get this delegate from a GameViewportClient::OnOverrideInputKey()\n// Enable / disable whenever the \"Join Game\" screen visible / invisible void ThisClass::EnableListenForInput(bool bEnable) { bListenForLocalPlayerInput = bEnable; if (!bListenForLocalPlayerInput) { // Stop listening: restore the previous handler ViewportClient-\u003eOnOverrideInputKey() = CachedInputKeyHandler; CachedInputKeyHandler.Unbind(); } else { // Start listening: store the current handler so we can call it later CachedInputKeyHandler = ViewportClient-\u003eOnOverrideInputKey(); // Bind our custom function to intercept all key inputs ViewportClient-\u003eOnOverrideInputKey().BindUObject(this, \u0026ThisClass::OnAnyInputKeyEvent); } } In the function\nbool ThisClass::OnAnyInputKeyEvent(FInputKeyEventArgs\u0026 InputKeyEventArgs) { // Check if it's correct key, event, // Check if the local player exists yet by getting the Local Player using ControllerId // If the player not exists, then register // If the player exists, then unregister. BUT BEWARE OF NOT TO REMOVE THE PRIMARY PLAYER // If none of the condition matches above, you can return the input back to the flow so the player controller can capture it // By calling the CachedNative that we stored ealier CachedInputKeyHandler.Execute(InputKeyEventArgs); } Press any button screen This is a very common screen in any game. It seem useless but under the hood, it is registering the input device that press the key to control the primary local player. So that player can use that device to control the main menu. Imagining you have 4 gamepads connected to your game, without this screen, the player has to guess what gamepad is controlling the menu.\nSolution: We already have the knowledge about OnOverrideInputKey delegate from the previous section to listen for any device‚Äôs input without a specific player controller. So implementing this screen is quite simple:\nDisplay the ‚ÄúPress Any Button‚Äù widget. Bind to the OnOverrideInputKey delegate to start listening for input. When any device presses a button, use IPlatformInputDeviceMapper::Internal_ChangeInputDeviceUserMapping to assign that device to the primary player. Note that this function only reassigns a device from one local player to another as it doesn‚Äôt automatically swap them. So you must call it twice (once for each player) to complete the swap; otherwise, one player will have two devices assigned while the other has none. Unbind from OnOverrideInputKey to stop listening. Remove the ‚ÄúPress Any Button‚Äù widget. Local Splitscreen and Multiplayer You can have multiple local players on one machine and play with other online players.\nIt sounds daunting but Unreal actually supports both local splitscreen and online multiplayer at the same time quite well.\nUnreal supports sending split join (see ULocalPlayer::SendSplitJoin) for other Local Players when:\nClient Travel to a multiplayer session UGameInstance::CreateLocalPlayer is called on a multiplayer session Notes Your graphic will automatically degrade for splitscreen rendering This is understandable since you only have 1 hardware but now you‚Äôre simulating more than 1 player. The budget will be split down maximum 4 times. So Unreal have some mechanism to degrade the rendering quality by disabling some features.\nProblem: The most important note here is Lumen will be disabled if you have MORE THAN 2 local players in your game. It is clear that Lumen can be quite heavy even for one player. Even if you are building your game for high spec machine, Unreal haven‚Äôt provide any settings to turn this on.\nSolution: This can only fixed if you use custom build engine LumenDefinitions.h has the field #define LUMEN_MAX_VIEWS 2 which limits the lumen capacity. But increasing that number will cause the engine failed to compile because some of the lumen code is fixed to 2 and not use the constant macro. However, I fixed it you can cherry pick my Git Commit which has been commit to ue5-main.\nKeyboard and First Gamepad will have the same FInputDeviceId Problem: This causes problems when swapping devices. Unreal treats both the keyboard and the first gamepad as the same device, so swapping one also swaps the other. If you want to swap Gamepad ID 1 with Gamepad ID 0 of Player 1, Unreal swaps ID 1 and ID 0. Because the keyboard also uses ID 0, it gets swapped too.\nExample:\nPlayer 1: - Gamepad ‚Äî ID 0 - Keyboard ‚Äî ID 0 Unassigned: - Gamepad ‚Äî ID 1 Result:\nPlayer 1: - Gamepad ‚Äî ID 1 Unassigned: - Gamepad ‚Äî ID 0 - Keyboard ‚Äî ID 0 Important: This can make your player 1 (primary player) lose keyboard/mouse control. Not a critical bug, but important to know so it doesn‚Äôt waste hours of debugging.\n","wordCount":"2347","inLanguage":"en","image":"https://teambaconn.github.io/posts/local-coop/splitscreen.gif","datePublished":"2025-12-02T01:34:25+07:00","dateModified":"2025-12-02T01:34:25+07:00","author":{"@type":"Person","name":"Tuong Nguyen, aka Bacon"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://teambaconn.github.io/unreal-post/local-coop/"},"publisher":{"@type":"Organization","name":"BaconGameDev's Blog","logo":{"@type":"ImageObject","url":"https://teambaconn.github.io/logo.png"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://teambaconn.github.io/ accesskey=h title="BaconGameDev's Blog (Alt + H)">BaconGameDev's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://teambaconn.github.io/plugin/ title="My Plugins"><span>My Plugins</span></a></li><li><a href=https://teambaconn.github.io/unreal-post/ title="UE Blog"><span>UE Blog</span></a></li><li><a href=https://teambaconn.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://teambaconn.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://teambaconn.github.io/archives/ title=Archives><span>Archives</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://teambaconn.github.io/>Home</a>&nbsp;¬ª&nbsp;<a href=https://teambaconn.github.io/unreal-post/>Unreal-Posts</a></div><h1 class="post-title entry-hint-parent">[Unreal] Splitscreen Multiplayer Guide</h1><div class=post-meta><span title='2025-12-02 01:34:25 +0700 +07'>December 2, 2025</span>&nbsp;¬∑&nbsp;12 min&nbsp;¬∑&nbsp;Tuong Nguyen, aka Bacon</div></header><figure class=entry-cover><img loading=eager src=https://teambaconn.github.io/posts/local-coop/splitscreen.gif alt></figure><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#abstract aria-label=Abstract>Abstract</a></li><li><a href=#-random-guides aria-label="‚öôÔ∏è Random guides">‚öôÔ∏è Random guides</a><ul><li><a href=#-definitions aria-label="üß± Definitions">üß± Definitions</a></li><li><a href=#-create--remove-local-player aria-label="üóø Create / Remove Local Player">üóø Create / Remove Local Player</a></li><li><a href=#-widgets-in-local-splitscreen aria-label="ü™ü Widgets in Local Splitscreen">ü™ü Widgets in Local Splitscreen</a><ul><li><a href=#adding-widget-to-global--local-viewport aria-label="Adding Widget to Global & Local viewport">Adding Widget to Global & Local viewport</a></li><li><a href=#widgetcomponent aria-label=WidgetComponent>WidgetComponent</a></li></ul></li><li><a href=#main-menu-in-splitscreen-games aria-label="Main menu in splitscreen games">Main menu in splitscreen games</a><ul><li><a href=#displaying-the-menu aria-label="Displaying the Menu">Displaying the Menu</a></li><li><a href=#decide-who-can-control-and-interact-with-the-menu aria-label="Decide who can control and interact with the Menu">Decide who can control and interact with the Menu</a></li></ul></li><li><a href=#discorver-new-players aria-label="Discorver new players">Discorver new players</a><ul><li><a href=#1-let-the-primary-player-registerunregister-others aria-label="1. Let the Primary Player Register/Unregister Others">1. Let the Primary Player Register/Unregister Others</a></li><li><a href=#2-let-input-devices-register-themselves aria-label="2. Let Input Devices Register Themselves">2. Let Input Devices Register Themselves</a></li></ul></li><li><a href=#press-any-button-screen aria-label="Press any button screen">Press any button screen</a></li><li><a href=#local-splitscreen-and-multiplayer aria-label="Local Splitscreen and Multiplayer">Local Splitscreen and Multiplayer</a></li></ul></li><li><a href=#notes aria-label=Notes>Notes</a><ul><li><a href=#your-graphic-will-automatically-degrade-for-splitscreen-rendering aria-label="Your graphic will automatically degrade for splitscreen rendering">Your graphic will automatically degrade for splitscreen rendering</a></li><li><a href=#keyboard-and-first-gamepad-will-have-the-same-finputdeviceid aria-label="Keyboard and First Gamepad will have the same FInputDeviceId">Keyboard and First Gamepad will have the same FInputDeviceId</a></li></ul></li></ul></div></details></div><div class=post-content><h1 id=abstract>Abstract<a hidden class=anchor aria-hidden=true href=#abstract>#</a></h1><p>It‚Äôs been a while since my last blog post! Recently, I‚Äôve been fully focused on developing my game <strong>Project Brawl</strong> - a beat ‚Äôem up with local co-op and multiplayer support. And as the title suggests, I ran into quite a few headaches while developing the <strong>local co-op features</strong>.</p><p>Although Unreal technically supports splitscreen out of the box, there‚Äôs <strong>almost no proper documentation</strong> from Epic explaining how to actually use it in a real project. Every tutorial out there just says something like:</p><blockquote><p>‚ÄúGo to Project Settings, enable <em>Use Splitscreen</em>, and call <code>CreateLocalPlayer()</code>.‚Äù</p></blockquote><p>So I thought, <em>&ldquo;Local multiplayer? Easy! Let‚Äôs do it!&rdquo;</em> ‚Äî and then spent <strong>weeks</strong> struggling to make Unreal‚Äôs <strong>already supported</strong> feature work as expected. Hopefully, by sharing what I‚Äôve learned here, I can save you a lot of that time and frustration and help you get your game <em>local-coop ready</em> much faster üòÑ</p><hr><h1 id=-random-guides>‚öôÔ∏è Random guides<a hidden class=anchor aria-hidden=true href=#-random-guides>#</a></h1><h2 id=-definitions>üß± Definitions<a hidden class=anchor aria-hidden=true href=#-definitions>#</a></h2><p>Before diving in, let&rsquo;s clarify the key terminology you&rsquo;ll encounter:</p><p><details><summary><strong><code>FInputDeviceId</code></strong></summary><div><blockquote><ul><li>An ID that identifies a specific input device (keyboard, gamepad, etc.)</li></ul></blockquote></div></details><br><details><summary><strong><code>FPlatformUserId</code></strong></summary><div><blockquote><ul><li>An ID that identifies a LocalPlayer</li></ul></blockquote></div></details><br><details><summary><strong><code>ControllerId</code></strong></summary><div><blockquote><ul><li>An old int32 ID used to identify a <code>LocalPlayer</code></li><li>Epic is replacing this with <code>FPlatformUserId</code> in future versions</li><li><strong>Important:</strong> Do not confuse this with <code>PlayerController</code></li></ul></blockquote></div></details><br><details><summary><strong><code>Local Player</code></strong></summary><div><blockquote><ul><li>Stores information about a &ldquo;local&rdquo; player on your game&rsquo;s running machine</li><li>Contains all the <code>InputDeviceId</code>s connected to that player and a <code>FPlatformUserId</code> to identify itself</li><li><strong>Note:</strong> This is not the same as <code>PlayerController</code></li><li>A <code>LocalPlayer</code> does not guarantee to have a <code>PlayerController</code> and vice versa (depends on the context)</li></ul></blockquote></div></details><br><details><summary><strong><code>Primary Player</code></strong></summary><div><blockquote><ul><li>The first local player created in the game</li><li>Different on each client in a multiplayer game</li></ul></blockquote></div></details></p><br><p><strong>Relationship hierarchy:</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>LocalPlayer ‚Üí PlayerController ‚Üí Pawn
</span></span></code></pre></div><hr><h2 id=-create--remove-local-player>üóø Create / Remove Local Player<a hidden class=anchor aria-hidden=true href=#-create--remove-local-player>#</a></h2><p>All of the local players are stored in the <code>GameInstance</code>. To create and remove a local player it&rsquo;s quite simple as calling function</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>ULocalPlayer</span><span class=o>*</span> <span class=nf>CreateLocalPlayer</span><span class=p>(</span><span class=n>int32</span> <span class=n>ControllerId</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>                                <span class=n>FString</span><span class=o>&amp;</span> <span class=n>OutError</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>                                <span class=kt>bool</span> <span class=n>bSpawnPlayerController</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>ULocalPlayer</span><span class=o>*</span> <span class=nf>CreateLocalPlayer</span><span class=p>(</span><span class=n>FPlatformUserId</span> <span class=n>UserId</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>                                <span class=n>FString</span><span class=o>&amp;</span> <span class=n>OutError</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>                                <span class=kt>bool</span> <span class=n>bSpawnPlayerController</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Becareful when using this, as you can accidentally remove the primary local player
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>bool</span> <span class=nf>RemoveLocalPlayer</span><span class=p>(</span><span class=n>ULocalPlayer</span> <span class=o>*</span> <span class=n>ExistingPlayer</span><span class=p>);</span>
</span></span></code></pre></div><p><br><br><span style="background-color:#ffea00;padding:4px 2px 4px 8px;margin:0;border-radius:2px;font-size:95%"><span style=color:#000;font-weight:700>Notes:
</span></span>&nbsp;</p><ul><li>If you have no clue how to get the ControllerId or UserId and just want to spawn a new player, just use ControllerId -1. It should automatically create a new LocalPlayer for you.</li></ul><blockquote></blockquote><ul><li><strong>You should always spawn the player controller</strong> (by setting <code>bSpawnPlayerController = true</code>). There are no reason you want to spawn the LocalPlayer without PlayerController since it will automatically spawn a PlayerController for you after switching level. The only reason I can see you doing this is: It&rsquo;s middle of the game, you still want to create a LocalPlayer but not actually doing anything because the game is in progress. And it will automatically spawn the PlayerController after the game ends and switch level. But why letting that, instead just wait until the game finishes? It will create more unexpected behaviors (believe me, I go through the hard way)</li></ul><hr><h2 id=-widgets-in-local-splitscreen>ü™ü Widgets in Local Splitscreen<a hidden class=anchor aria-hidden=true href=#-widgets-in-local-splitscreen>#</a></h2><p>Working with widgets in local splitscreen can be tricky if you&rsquo;re only familiar with single-player games. The key concept to understand is:<br><br><span style="background-color:#ffae00;padding:4px 2px 4px 8px;margin:0;border-radius:2px;font-size:95%"><span style=color:#000;font-weight:700>Each widget is owned by a LOCAL PLAYER and only that player can interact with it
</span></span>&nbsp;</p><br><h3 id=adding-widget-to-global--local-viewport>Adding Widget to Global & Local viewport<a hidden class=anchor aria-hidden=true href=#adding-widget-to-global--local-viewport>#</a></h3><figure><img loading=lazy src=/posts/local-coop/add-widget.png width=100%></figure><p>Unreal provides 2 functions to add widgets to the screen:</p><ul><li><p><strong><code>UUserWidget::AddToViewport(int32 ZOrder)</code></strong></p><ul><li>Adds the widget to the <strong>global viewport</strong> (overlaps all splitscreens when the screen is split)</li></ul><blockquote></blockquote><ul><li>Use this for <strong>global widgets</strong> like:<ul><li>Pause menus</li><li>Main menus</li><li>Global announcements</li></ul></li></ul></li><li><p><strong><code>UUserWidget::AddToPlayerScreen(int32 ZOrder)</code></strong></p><ul><li>Adds the widget to a <strong>specific local player&rsquo;s viewport</strong></li></ul><blockquote></blockquote><ul><li>Which player&rsquo;s screen receives the widget depends on the <code>OwningPlayer</code> (PlayerController) you pass when creating the widget</li></ul><blockquote></blockquote><ul><li>Use this for <strong>player-specific widgets</strong> like:<ul><li>Player HUD</li><li>Player&rsquo;s local pause menu / settings (like in Lyra)</li></ul></li></ul></li></ul><br><p>‚ö†Ô∏è <strong>Important:</strong> Always assign the <code>OwningPlayer</code> when creating widgets. If left blank, Unreal automatically assigns it to the first Local Player (primary player), or to itself if called from within a PlayerController (see <code>UUserWidget::CreateWidgetInstance</code> for details). While this works for single-player games, <strong>local co-op games need deterministic ownership</strong> to function correctly.</p><br><hr><h3 id=widgetcomponent>WidgetComponent<a hidden class=anchor aria-hidden=true href=#widgetcomponent>#</a></h3><p>When creating character health bars, you&rsquo;ll likely use WidgetComponent to display widgets in either World Space or Screen Space. While both look similar, they behave very differently in local co-op:</p><p><strong>World Space:</strong></p><ul><li>Renders the widget on a mesh</li><li><strong>Visible to any players seeing that mesh</strong></li></ul><br><p><strong>Screen Space:</strong></p><ul><li>Widget behaves as if in world space, but is added to <strong>A OWNING PLAYER&rsquo;S SCREEN</strong></li><li><strong>Only visible to the owning player</strong></li></ul><br><p><span style="background-color:red;padding:4px 2px 4px 8px;margin:0;border-radius:2px;font-size:95%"><span style=color:#000;font-weight:700>Problem:
</span></span>&nbsp;<br><a href=https://forums.unrealengine.com/t/split-screen-ui-widget-component-showing-only-in-player-0-screen/1654616><strong>Split Screen UI widget Component Showing only in Player 0 screen</strong></a>.</p><p>TL;DR: In a 4-player co-op game with Screen Space widgets, only the owning player will see other&rsquo;s health bar and the other 3 players won&rsquo;t see anything at all.</p><p><strong>Even worse:</strong> Unreal&rsquo;s implementation is non-deterministic and changes between engine versions:</p><ul><li><strong>Unreal 5.4 and below:</strong> The FIRST local player becomes the owner, meaning only the FIRST player sees the widget</li><li><strong>Unreal 5.5 and above:</strong> If the WidgetComponent is attached to a Pawn with a PlayerController, that player becomes the owner, meaning players can only see health bars on themselves, but cannot see others&rsquo; health bars in their viewports.</li></ul><br><p><span style="background-color:#ffea00;padding:4px 2px 4px 8px;margin:0;border-radius:2px;font-size:95%"><span style=color:#000;font-weight:700>Solution:
</span></span>&nbsp;<br>There are solutions on the internet that suggest that you should manually create each WidgetComponent for each local player and assign ownership accordingly. However, this approach is <strong>tedious, error-prone, and can break with engine updates</strong>. So instead, here&rsquo;s my take:</p><p>Create an <strong>Actor Component that manages WidgetComponents</strong> to ensure all players see all Screen Space widgets, remaining stable across engine versions:</p><p><strong>On Initialization:</strong></p><ol><li>Find all WidgetComponents (Screen Space only) on the actor</li><li>Store them in an &ldquo;Original List&rdquo;</li><li>Disable each original by calling <code>SetWidget(nullptr)</code></li><li>For each LocalPlayer currently in the game, run the &ldquo;LocalPlayer Added&rdquo; logic below</li><li>Listen for LocalPlayer added/removed events (from GameInstance) and run the respective logic</li></ol><p><strong>When a LocalPlayer is Added:</strong></p><ol><li>For each WidgetComponent in the Original List:<ul><li>Create a new WidgetComponent instance</li><li>Copy all settings from the original</li><li>Call <code>UWidgetComponent::SetOwnerPlayer()</code> with the newly added LocalPlayer</li><li>Store this cloned widget component for later cleanup</li></ul></li></ol><p><strong>When a LocalPlayer is Removed:</strong></p><ol><li>For each cloned widget component:<ul><li>Check if its <code>OwnerPlayer</code> matches the removed player</li><li>If yes, destroy/remove that cloned widget</li></ul></li></ol><br><p><strong>Notes:</strong></p><ul><li>Each widget component will now have N copies (where N = number of local players)</li><li>It&rsquo;s recommended that the widget components should hook into game events to update all copies simultaneously</li></ul><hr><h2 id=main-menu-in-splitscreen-games>Main menu in splitscreen games<a hidden class=anchor aria-hidden=true href=#main-menu-in-splitscreen-games>#</a></h2><h3 id=displaying-the-menu>Displaying the Menu<a hidden class=anchor aria-hidden=true href=#displaying-the-menu>#</a></h3><p>This is different than ingame UIs since ingame UIs are displayed separately for each local players. For main menu UI, most games use one single screen to display the menu.</p><figure><img loading=lazy src=/posts/local-coop/menu-ui.png width=100%></figure><p><span style="background-color:red;padding:4px 2px 4px 8px;margin:0;border-radius:2px;font-size:95%"><span style=color:#000;font-weight:700>Problem:
</span></span>&nbsp;
If splitscreen is still active, the menu appears across multiple viewports, causing the screen to be split even though you only want one unified menu display.<br><br><span style="background-color:#ffea00;padding:4px 2px 4px 8px;margin:0;border-radius:2px;font-size:95%"><span style=color:#000;font-weight:700>Solution:
</span></span>&nbsp;
Use <code>UGameplayStatics::SetForceDisableSplitscreen(GetWorld(), bDisable);</code>. This forces the game to use one fullscreen viewport, allowing the menu to display correctly.</p><br><h3 id=decide-who-can-control-and-interact-with-the-menu>Decide who can control and interact with the Menu<a hidden class=anchor aria-hidden=true href=#decide-who-can-control-and-interact-with-the-menu>#</a></h3><ul><li><strong>Only the primary player can control the Menu</strong><br>Most games do this, and it&rsquo;s the default behavior in Unreal.</li></ul><br><ul><li><strong>Every local players can control the Menu with the same pointer</strong><br>This easily becomes chaotic. I wouldn&rsquo;t recommend this but if you still want to do this, use <code>IPlatformInputDeviceMapper::Internal_ChangeInputDeviceUserMapping</code> to map every input device of other local player to the primary local player. By doing that, every devices now have control of the menu. But make sure to returns it back once you&rsquo;re in-game.</li></ul><br><ul><li><strong>Each local player has their own pointer</strong><br><figure><img loading=lazy src=/posts/local-coop/selection-screen.png width=100%></figure><em><em>This is for educational purpose, please Nintendo, don&rsquo;t sue my ass.</em></em><br><br>You will see this mostly in character selection menu in fighting games where you have P1 and P2 pointer floating around to indicate that player&rsquo;s champion selection. This is hard & kinna tedious to implement in my opinion.<br><br><strong>You will need:</strong><ul><li>One shared widget containing all the actual menu buttons.</li><li>A separate ‚Äúpointer widget‚Äù for each player, showing only their cursor and selection state.</li><li>Pointer widgets mirror button positions/behavior from the shared widget (using CommonUI) and sync any shared actions (e.g., locking characters).</li></ul></li></ul><br><hr><h2 id=discorver-new-players>Discorver new players<a hidden class=anchor aria-hidden=true href=#discorver-new-players>#</a></h2><p>You already know how to manually add or remove local players.
But how do you let <strong>players themselves</strong> decide how many should join a session?</p><p>There are two main approaches.</p><h3 id=1-let-the-primary-player-registerunregister-others>1. Let the Primary Player Register/Unregister Others<a hidden class=anchor aria-hidden=true href=#1-let-the-primary-player-registerunregister-others>#</a></h3><p><figure><img loading=lazy src=/posts/local-coop/register-player-old.png width=100%></figure>This is the most simple way to implement.</p><p>You will have a button or a slider that allow the primary player to add and remove local players. As you create new local players, it will automatically paired with any unpaired input device for you.</p><p>‚ö†Ô∏è But the binding is kinna random. If you have 4 gamepads connected and you only want 2 players in the session. Your players will have to figured out which in those 4 gamepads is currently controlling that 2 players.</p><br><h3 id=2-let-input-devices-register-themselves>2. Let Input Devices Register Themselves<a hidden class=anchor aria-hidden=true href=#2-let-input-devices-register-themselves>#</a></h3><figure><img loading=lazy src=/posts/local-coop/register-player.png width=100%></figure><p>This is what most party games do. A <strong>&ldquo;Join Game&rdquo;</strong> screen shows all available player slots, and anyone can join simply by pressing a button on their controller. The game detects which device sent the input and registers a new player using that device. This way, each player instantly knows which gamepad they‚Äôre using and the host doesn‚Äôt need to manage it manually.</p><p><span style="background-color:red;padding:4px 2px 4px 8px;margin:0;border-radius:2px;font-size:95%"><span style=color:#000;font-weight:700>Problem:
</span></span>&nbsp;<br>Only the <strong>primary player</strong> has a <code>PlayerController</code>, which can listen for input and interact with the UI. So how do we detect input from <strong>unpaired devices</strong> that don‚Äôt have a controller yet?</p><br><p><span style="background-color:#ffea00;padding:4px 2px 4px 8px;margin:0;border-radius:2px;font-size:95%"><span style=color:#000;font-weight:700>Solution:
</span></span>&nbsp;<br>Unreal provides a delegate that fires whenever <strong>any connected device</strong> presses or releases a key. Lyra‚Äôs source code includes an example of this system here‚Äôs the basic idea:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cm>/** Delegate for overriding key input before it is routed to player controllers, returning true means it was handled by delegate */</span>
</span></span><span class=line><span class=cl><span class=nf>DECLARE_DELEGATE_RetVal_OneParam</span><span class=p>(</span><span class=kt>bool</span><span class=p>,</span> <span class=n>FOverrideInputKeyHandler</span><span class=p>,</span> <span class=n>FInputKeyEventArgs</span><span class=o>&amp;</span> <span class=cm>/*EventArgs*/</span><span class=p>);</span>
</span></span></code></pre></div><p>You can get this delegate from a <code>GameViewportClient::OnOverrideInputKey()</code></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// Enable / disable whenever the &#34;Join Game&#34; screen visible / invisible
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=n>ThisClass</span><span class=o>::</span><span class=nf>EnableListenForInput</span><span class=p>(</span><span class=kt>bool</span> <span class=n>bEnable</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span> 
</span></span><span class=line><span class=cl>	<span class=n>bListenForLocalPlayerInput</span> <span class=o>=</span> <span class=n>bEnable</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>bListenForLocalPlayerInput</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// Stop listening: restore the previous handler
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=n>ViewportClient</span><span class=o>-&gt;</span><span class=nf>OnOverrideInputKey</span><span class=p>()</span> <span class=o>=</span> <span class=n>CachedInputKeyHandler</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=n>CachedInputKeyHandler</span><span class=p>.</span><span class=nf>Unbind</span><span class=p>();</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>else</span>
</span></span><span class=line><span class=cl>	<span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// Start listening: store the current handler so we can call it later
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=n>CachedInputKeyHandler</span> <span class=o>=</span> <span class=n>ViewportClient</span><span class=o>-&gt;</span><span class=nf>OnOverrideInputKey</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1>// Bind our custom function to intercept all key inputs
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=n>ViewportClient</span><span class=o>-&gt;</span><span class=nf>OnOverrideInputKey</span><span class=p>().</span><span class=nf>BindUObject</span><span class=p>(</span><span class=n>this</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>ThisClass</span><span class=o>::</span><span class=n>OnAnyInputKeyEvent</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span> 
</span></span></code></pre></div><p>In the function</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>bool</span> <span class=n>ThisClass</span><span class=o>::</span><span class=nf>OnAnyInputKeyEvent</span><span class=p>(</span><span class=n>FInputKeyEventArgs</span><span class=o>&amp;</span> <span class=n>InputKeyEventArgs</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Check if it&#39;s correct key, event,
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=c1>// Check if the local player exists yet by getting the Local Player using ControllerId
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=c1>// If the player not exists, then register
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=c1>// If the player exists, then unregister. BUT BEWARE OF NOT TO REMOVE THE PRIMARY PLAYER
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=c1>// If none of the condition matches above, you can return the input back to the flow so the player controller can capture it
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// By calling the CachedNative that we stored ealier
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>CachedInputKeyHandler</span><span class=p>.</span><span class=nf>Execute</span><span class=p>(</span><span class=n>InputKeyEventArgs</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><br><hr><h2 id=press-any-button-screen>Press any button screen<a hidden class=anchor aria-hidden=true href=#press-any-button-screen>#</a></h2><p><figure><img loading=lazy src=/posts/local-coop/press-any-button.png width=100%></figure>This is a very common screen in any game. It seem useless but under the hood, it is registering the input device that press the key to control the primary local player. So that player can use that device to control the main menu. Imagining you have 4 gamepads connected to your game, without this screen, the player has to guess what gamepad is controlling the menu.</p><br><span style="background-color:#ffea00;padding:4px 2px 4px 8px;margin:0;border-radius:2px;font-size:95%"><span style=color:#000;font-weight:700>Solution:
</span></span>&nbsp;<p>We already have the knowledge about <code>OnOverrideInputKey</code> delegate from the <a href=#2-let-input-devices-register-themselves>previous section</a> to listen for any device&rsquo;s input without a specific player controller. So implementing this screen is quite simple:</p><ol><li>Display the ‚ÄúPress Any Button‚Äù widget.</li></ol><blockquote></blockquote><ol start=2><li>Bind to the <code>OnOverrideInputKey</code> delegate to start listening for input.</li></ol><blockquote></blockquote><ol start=3><li>When any device presses a button, use <code>IPlatformInputDeviceMapper::Internal_ChangeInputDeviceUserMapping</code> to assign that device to the <strong>primary player</strong>. Note that this function only reassigns a device from one local player to another as it doesn‚Äôt automatically swap them. So you must call it <strong>twice</strong> (once for each player) to complete the swap; otherwise, one player will have two devices assigned while the other has none.</li></ol><blockquote></blockquote><ol start=4><li>Unbind from <code>OnOverrideInputKey</code> to stop listening.</li></ol><blockquote></blockquote><ol start=5><li>Remove the ‚ÄúPress Any Button‚Äù widget.</li></ol><hr><h2 id=local-splitscreen-and-multiplayer>Local Splitscreen and Multiplayer<a hidden class=anchor aria-hidden=true href=#local-splitscreen-and-multiplayer>#</a></h2><p><figure><img loading=lazy src=/posts/local-coop/multiplayer.png width=100%></figure><em>You can have multiple local players on one machine and play with other online players.</em></p><p>It sounds daunting but Unreal actually supports both local splitscreen and online multiplayer at the same time quite well.</p><p>Unreal supports sending split join (see ULocalPlayer::SendSplitJoin) for other Local Players when:</p><ul><li>Client Travel to a multiplayer session</li><li><code>UGameInstance::CreateLocalPlayer</code> is called on a multiplayer session</li></ul><hr><h1 id=notes>Notes<a hidden class=anchor aria-hidden=true href=#notes>#</a></h1><h2 id=your-graphic-will-automatically-degrade-for-splitscreen-rendering>Your graphic will automatically degrade for splitscreen rendering<a hidden class=anchor aria-hidden=true href=#your-graphic-will-automatically-degrade-for-splitscreen-rendering>#</a></h2><p>This is understandable since you only have 1 hardware but now you&rsquo;re simulating more than 1 player. The budget will be split down maximum 4 times. So Unreal have some mechanism to degrade the rendering quality by disabling some features.</p><br><p><span style="background-color:red;padding:4px 2px 4px 8px;margin:0;border-radius:2px;font-size:95%"><span style=color:#000;font-weight:700>Problem:
</span></span>&nbsp;<br>The most important note here is Lumen will be disabled if you have <strong>MORE THAN</strong> 2 local players in your game. It is clear that Lumen can be quite heavy even for one player. Even if you are building your game for high spec machine, Unreal haven&rsquo;t provide any settings to turn this on.</p><br><p><span style="background-color:#ffea00;padding:4px 2px 4px 8px;margin:0;border-radius:2px;font-size:95%"><span style=color:#000;font-weight:700>Solution:
</span></span>&nbsp;<br>This can only fixed if you use custom build engine <code>LumenDefinitions.h</code> has the field <code>#define LUMEN_MAX_VIEWS 2</code> which limits the lumen capacity. But increasing that number will cause the engine failed to compile because some of the lumen code is fixed to 2 and not use the constant macro. However, I fixed it you can cherry pick my <a href=https://github.com/EpicGames/UnrealEngine/commit/e31f47472103b4dbd006d0a27e87e1960b4133e2>Git Commit</a> which has been commit to <code>ue5-main</code>.</p><hr><h2 id=keyboard-and-first-gamepad-will-have-the-same-finputdeviceid>Keyboard and First Gamepad will have the same FInputDeviceId<a hidden class=anchor aria-hidden=true href=#keyboard-and-first-gamepad-will-have-the-same-finputdeviceid>#</a></h2><p><span style="background-color:red;padding:4px 2px 4px 8px;margin:0;border-radius:2px;font-size:95%"><span style=color:#000;font-weight:700>Problem:
</span></span>&nbsp;<br>This causes problems when swapping devices. Unreal treats both the keyboard and the first gamepad as the same device, so swapping one also swaps the other. If you want to swap Gamepad ID 1 with Gamepad ID 0 of Player 1, Unreal swaps ID 1 and ID 0. Because the keyboard also uses ID 0, it gets swapped too.</p><p><strong>Example:</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Player 1:
</span></span><span class=line><span class=cl>- Gamepad ‚Äî ID 0
</span></span><span class=line><span class=cl>- Keyboard ‚Äî ID 0
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Unassigned:
</span></span><span class=line><span class=cl>- Gamepad ‚Äî ID 1
</span></span></code></pre></div><p><strong>Result:</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Player 1:
</span></span><span class=line><span class=cl>- Gamepad ‚Äî ID 1
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Unassigned:
</span></span><span class=line><span class=cl>- Gamepad ‚Äî ID 0
</span></span><span class=line><span class=cl>- Keyboard ‚Äî ID 0
</span></span></code></pre></div><br><p><span style="background-color:#ffea00;padding:4px 2px 4px 8px;margin:0;border-radius:2px;font-size:95%"><span style=color:#000;font-weight:700>Important:
</span></span>&nbsp;<br>This can make your player 1 (primary player) lose keyboard/mouse control. Not a critical bug, but important to know so it doesn&rsquo;t waste hours of debugging.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://teambaconn.github.io/tags/game/>Game</a></li><li><a href=https://teambaconn.github.io/tags/unreal/>Unreal</a></li><li><a href=https://teambaconn.github.io/tags/coop/>Coop</a></li><li><a href=https://teambaconn.github.io/tags/multiplayer/>Multiplayer</a></li></ul><nav class=paginav><a class=next href=https://teambaconn.github.io/unreal-post/common-ui-input-routing/><span class=title>Next ¬ª</span><br><span>[Unreal] How CommonUI route your input</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://teambaconn.github.io/>BaconGameDev's Blog</a></span> ¬∑
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>